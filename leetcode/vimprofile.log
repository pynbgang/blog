FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/quickfix.vim line 28
Called 8 times
Total time:   0.000394
 Self time:   0.000349

count  total (s)   self (s)
    8   0.000208   0.000163   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
    2              0.000085     call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    8              0.000020   endif

FUNCTION  <SNR>115_winshell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 74
Called 10 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
   10              0.000186   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>86_Tlist_Skip_File()
    Defined: ~/.vim/bundle/taglist.vim/plugin/taglist.vim line 797
Called 4 times
Total time:   0.007937
 Self time:   0.007937

count  total (s)   self (s)
                                " Skip buffers with no names and buffers with filetype not set
    4              0.000026     if a:filename == '' || a:ftype == ''
                                    return 1
    4              0.000007     endif
                            
                                " Skip files which are not supported by exuberant ctags
                                " First check whether default settings for this filetype are available.
                                " If it is not available, then check whether user specified settings are
                                " available. If both are not available, then don't list the tags for this
                                " filetype
    4              0.000025     let var = 's:tlist_def_' . a:ftype . '_settings'
    4              0.000034     if !exists(var)
    2              0.000012         let var = 'g:tlist_' . a:ftype . '_settings'
    2              0.000011         if !exists(var)
    2              0.000007             return 1
                                    endif
    2              0.000003     endif
                            
                                " Skip files which are not readable or files which are not yet stored
                                " to the disk
    2              0.007650     if !filereadable(a:filename)
                                    return 1
    2              0.000006     endif
                            
    2              0.000007     return 0

FUNCTION  3()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 47
Called 696 times
Total time:   9.593555
 Self time:   0.526840

count  total (s)   self (s)
  696   0.036161   0.012173     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
  696              0.001999     if self.isExecutable
  688   0.042050   0.007688         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
  696              0.001718     endif
                            
  696              0.005879     let self._bookmarkNames = []
16704   0.071993   0.059674     for i in g:NERDTreeBookmark.Bookmarks()
16008   9.166902   0.170856         if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
16008              0.034859         endif
16704              0.039520     endfor
  696              0.004303     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
  696              0.001842     endif
                            
  696              0.001885     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
  696              0.001277     endif
                            
  696              0.002994     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
  696              0.001310     endif

FUNCTION  4()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 74
Called 688 times
Total time:   0.034362
 Self time:   0.034362

count  total (s)   self (s)
  688              0.022674     if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
                                    return a:line
  688              0.001392     else
  688              0.003860         return a:line . g:NERDTreeNodeDelimiter
                                endif

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 111
Called 8 times
Total time:   0.005330
 Self time:   0.000855

count  total (s)   self (s)
    8   0.005289   0.000814   return airline#extensions#ale#get('error')

FUNCTION  xolox#easytags#session_is_loading()
    Defined: ~/.vim/bundle/vim-easytags/autoload/xolox/easytags.vim line 572
Called 7 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    7              0.000054   return exists('g:SessionLoad')

FUNCTION  <SNR>173_get_transitioned_seperator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 143
Called 162 times
Total time:   0.401561
 Self time:   0.019212

count  total (s)   self (s)
  162              0.000946   let line = ''
  162              0.002652   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
  162              0.000378   else
  162   0.387901   0.005552     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  162              0.001516     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  162              0.001251     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  162              0.000827     let line .= '%#'.a:group.'#'
  162              0.000349   endif
  162              0.000648   return line

FUNCTION  airline#check_mode()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 199
Called 88 times
Total time:   0.962009
 Self time:   0.036430

count  total (s)   self (s)
   88              0.000653   if !has_key(s:contexts, a:winnr)
                                return ''
   88              0.000233   endif
   88              0.000629   let context = s:contexts[a:winnr]
                            
   88              0.000779   if get(w:, 'airline_active', 1)
   55              0.000331     let l:m = mode(1)
   55              0.000204     if l:m ==# "i"
                                  let l:mode = ['insert']
   55              0.000285     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
   55              0.000170     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   55              0.000227     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   55              0.001207     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   55              0.000199     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   55              0.000251     elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
   55              0.000185     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   55              0.000257     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
   55              0.000127     else
   55              0.003095       let l:mode = ['normal']
   55              0.000130     endif
   55              0.000466     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
   55              0.000127     endif
   55              0.001053     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
   55              0.000686       let l:m = l:m[0]
   55              0.000127     endif
   55              0.000974     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   33              0.000081   else
   33              0.000198     let l:mode = ['inactive']
   33              0.000626     let w:airline_current_mode = get(g:airline_mode_map, '__')
   88              0.000207   endif
                            
   88              0.000660   if g:airline_detect_modified && &modified
   10              0.000069     call add(l:mode, 'modified')
   88              0.000185   endif
                            
   88              0.000396   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
   88              0.000179   endif
                            
   88              0.000730   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
   88              0.000191   endif
                            
   88              0.000376   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
   88              0.000236   endif
                            
   88              0.000293   if &readonly || ! &modifiable
   33              0.000263     call add(l:mode, 'readonly')
   88              0.000354   endif
                            
   88              0.000687   let mode_string = join(l:mode)
   88              0.000798   if get(w:, 'airline_lastmode', '') != mode_string
    4   0.003364   0.000133     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    4   0.921448   0.000276     call airline#highlighter#highlight(l:mode, context.bufnr)
    4   0.001384   0.000208     call airline#util#doautocmd('AirlineModeChanged')
    4              0.000027     let w:airline_lastmode = mode_string
   88              0.000305   endif
                            
   88              0.000274   return ''

FUNCTION  nerdtree#renderView()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim line 252
Called 8 times
Total time:   0.859696
 Self time:   0.000103

count  total (s)   self (s)
    8   0.859673   0.000080     call b:NERDTree.render()

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 167
Called 8 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
    8              0.000075   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
    8              0.000073   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
    8              0.000016   endif

FUNCTION  <SNR>182_GetCounts()
    Defined: ~/.vim/bundle/ale/autoload/ale/statusline.vim line 97
Called 16 times
Total time:   0.001527
 Self time:   0.000894

count  total (s)   self (s)
   16   0.000679   0.000355     if !s:BufferCacheExists(a:buffer)
   16   0.000768   0.000459         return s:CreateCountDict()
                                endif
                            
                                call s:UpdateCacheIfNecessary(a:buffer)
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  indent_guides#disable()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim line 67
Called 8 times
Total time:   0.004008
 Self time:   0.000391

count  total (s)   self (s)
    8              0.000047   let g:indent_guides_autocmds_enabled = 0
    8   0.003815   0.000198   call indent_guides#clear_matches()

FUNCTION  airline#extensions#tabline#tabs#tabnr_formatter()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/tabs.vim line 123
Called 96 times
Total time:   0.011681
 Self time:   0.008435

count  total (s)   self (s)
   96              0.001505   let formatter = get(g:, 'airline#extensions#tabline#tabnr_formatter', 'tabnr')
   96              0.000353   try
   96   0.007083   0.003837     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, a:i)
                              catch /^Vim\%((\a\+)\)\=:E117/	" catch E117, unknown function
                                " Function not found
                                return call(formatter, [a:nr, a:i])
                              catch
                                " something went wrong, return an empty string
                                return ""
   96              0.000272   endtry

FUNCTION  <SNR>115_not_git_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 65
Called 15 times
Total time:   0.008317
 Self time:   0.000766

count  total (s)   self (s)
   15   0.008210   0.000659   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>87_on_window_changed()
    Defined: ~/.vim/bundle/vim-airline/plugin/airline.vim line 48
Called 4 times
Total time:   0.285654
 Self time:   0.000632

count  total (s)   self (s)
    4              0.000032   let s:active_winnr = winnr()
                            
    4              0.000025   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
    4              0.000010   endif
                              " work around a neovim bug: do not trigger on floating windows
                              " Disabled, Bug is fixed in Neovim, TODO: should be removed soon
                              " if exists("*nvim_win_get_config") && !empty(nvim_win_get_config(0).relative)
                              "  return
                              " endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    4              0.000111   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    4              0.000052   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
                                return
    4              0.000009   endif
    4              0.000052   let g:airline_last_window_changed = l:key
    4   0.000175   0.000093   call s:init()
    4   0.285042   0.000102   call airline#update_statusline()

FUNCTION  voom#BodyBufLeave()
    Defined: ~/.vim/bundle/VOoM/autoload/voom.vim line 2386
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                            " Body BufLeave au needed because getbufvar() doesn't work with b:changedtick if Vim <7.3.105.
    2              0.000031     let s:voom_bodies[bufnr('')].tick = b:changedtick

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 102
Called 55 times
Total time:   0.005277
 Self time:   0.002366

count  total (s)   self (s)
   55   0.005118   0.002207   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/netrw.vim line 10
Called 4 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
    4              0.000043   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    4              0.000009   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 82
Called 55 times
Total time:   0.001093
 Self time:   0.001093

count  total (s)   self (s)
   55              0.000317   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   55              0.000124   endif
   55              0.000135   return ''

FUNCTION  <SNR>173_get_seperator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 158
Called 202 times
Total time:   0.576107
 Self time:   0.031065

count  total (s)   self (s)
  202   0.245165   0.024269   if airline#builder#should_change_group(a:prev_group, a:group)
  130   0.328758   0.004612     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
   72              0.000177   else
   72              0.000441     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>150_is_excluded_window()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions.vim line 111
Called 10 times
Total time:   0.001526
 Self time:   0.001526

count  total (s)   self (s)
   10              0.000067   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   10              0.000027   endfor
                            
   40              0.000130   for matchw in g:airline_exclude_filenames
   30              0.000420     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   30              0.000070     endif
   40              0.000102   endfor
                            
   10              0.000043   if g:airline_exclude_preview && &previewwindow
                                return 1
   10              0.000020   endif
                            
   10              0.000032   return 0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim line 21
Called 17 times
Total time:   0.478521
 Self time:   0.002907

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   17   0.031824   0.000694   if gitgutter#utility#is_active(a:bufnr)
                            
   15              0.000167     if has('patch-7.4.1559')
   15              0.000217       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   15              0.000036     endif
   15   0.445184   0.000700     let how = s:setup_path(a:bufnr, l:Callback)
   15              0.000290     if [how] == ['async']  " avoid string-to-number conversion if how is a number
   15              0.000048       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
    2              0.000005   endif

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/.vim/bundle/ale/autoload/ale/events.vim line 51
Called 4 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    4              0.000049     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
    4              0.000013     endif
                            
                                " When entering a buffer, we are no longer quitting it.
    4              0.000044     call setbufvar(a:buffer, 'ale_quitting', 0)
    4              0.000035     let l:filetype = getbufvar(a:buffer, '&filetype')
    4              0.000050     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    4              0.000022     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
    4              0.000009     endif

FUNCTION  300()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 17
Called 114 times
Total time:   0.002801
 Self time:   0.002801

count  total (s)   self (s)
  114              0.001790   call add(self._sections, [a:group, a:contents])

FUNCTION  302()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 25
Called 96 times
Total time:   0.001684
 Self time:   0.001684

count  total (s)   self (s)
   96              0.001341   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  304()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 33
Called 12 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   12              0.000074   return len(self._sections)

FUNCTION  305()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 62
Called 36 times
Total time:   0.849131
 Self time:   0.129768

count  total (s)   self (s)
   36              0.000135   let side = 1
   36              0.000115   let line = ''
   36              0.000130   let i = 0
   36              0.000189   let length = len(self._sections)
   36              0.000194   let split = 0
   36              0.000224   let is_empty = 0
   36              0.000152   let prev_group = ''
                            
  340              0.001504   while i < length
  304              0.009280     let section = self._sections[i]
  304              0.001786     let group = section[0]
  304              0.001643     let contents = section[1]
  304              0.002861     let pgroup = prev_group
  304   0.021390   0.007990     let prev_group = airline#builder#get_prev_group(self._sections, i)
  304              0.002289     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
  304              0.002244     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    2              0.000013       let group = 'airline_c'. self._context.bufnr
  302              0.002030     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    2              0.000012       let prev_group = 'airline_c'. self._context.bufnr
  304              0.000720     endif
  304              0.000877     if is_empty
                                  let prev_group = pgroup
  304              0.000671     endif
  304   0.019716   0.008688     let is_empty = s:section_is_empty(self, contents)
                            
  304              0.001060     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
  304              0.000717     endif
                            
  304              0.001697     if group == ''
                                  let line .= contents
  304              0.001002     elseif group == '|'
   34              0.000105       let side = 0
   34              0.000201       let line .= contents
   34              0.000109       let split = 1
  270              0.000595     else
  270              0.000869       if prev_group == ''
   36              0.000248         let line .= '%#'.group.'#'
  234              0.000823       elseif split
   32              0.000089         if !is_empty
   32   0.078833   0.001418           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   32              0.000082         endif
   32              0.000112         let split = 0
  202              0.000445       else
  202              0.000998         if !is_empty
  202   0.592841   0.016734           let line .= s:get_seperator(self, prev_group, group, side)
  202              0.000533         endif
  270              0.000848       endif
  270   0.051199   0.009786       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  304              0.000713     endif
                            
  304              0.001756     let i = i + 1
  340              0.001207   endwhile
                            
   36              0.001319   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    8              0.002774     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   36              0.000125   endif
   36              0.000159   return line

FUNCTION  306()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 18
Called 12 times
Total time:   0.001404
 Self time:   0.001297

count  total (s)   self (s)
   12              0.000078   let self._first_title = a:first " lowest index
   12              0.000049   let self._last_title = a:last " highest index
   12              0.000061   let self._left_title = a:current " next index to add on the left
   12              0.000752   let self._right_title = a:current + 1 " next index to add on the right
   12   0.000300   0.000193   let self._left_position = self.get_position() " left end of titles
   12              0.000045   let self._right_position = self._left_position " right end of the titles

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 108
Called 15 times
Total time:   0.001559
 Self time:   0.000451

count  total (s)   self (s)
   15   0.001511   0.000403   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 279
Called 4 times
Total time:   0.000276
 Self time:   0.000186

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    4              0.000091   let g:airline#visual_active = (mode() =~? '[vs]')
    4   0.000150   0.000060   call airline#update_tabline()

FUNCTION  ale#Var()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim line 186
Called 29 times
Total time:   0.002133
 Self time:   0.002133

count  total (s)   self (s)
   29              0.000244     let l:full_name = 'ale_' . a:variable_name
   29              0.000340     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   29              0.001346     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  211()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim line 20
Called 8 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
    8              0.000063     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
    8              0.000015     endif
    8              0.000027     return self._flags[a:scope]

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 156
Called 4 times
Total time:   0.001176
 Self time:   0.000244

count  total (s)   self (s)
    4   0.001149   0.000217   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>174_build_sections()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim line 35
Called 14 times
Total time:   0.013596
 Self time:   0.002963

count  total (s)   self (s)
   72              0.000265   for key in a:keys
   58              0.000354     if (key == 'warning' || key == 'error') && !a:context.active
    8              0.000022       continue
   50              0.000102     endif
   50   0.011680   0.001047     call s:add_section(a:builder, a:context, key)
   64              0.000156   endfor

FUNCTION  <SNR>173_section_is_empty()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 185
Called 304 times
Total time:   0.011028
 Self time:   0.011028

count  total (s)   self (s)
  304              0.001448   let start=1
                            
                              " do not check for inactive windows or the tabline
  304              0.001261   if a:self._context.active == 0
   32              0.000086     return 0
  272              0.001776   elseif get(a:self._context, 'tabline', 0)
  240              0.000693     return 0
   32              0.000146   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   32              0.000194   if get(g:, 'airline_skip_empty_sections', 0) == 0
   32              0.000080     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim line 200
Called 12 times
Total time:   0.003844
 Self time:   0.001670

count  total (s)   self (s)
   12              0.000478   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
   12              0.000070   if get(g:, 'airline_powerline_fonts', 0)
   12              0.000177     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
   12              0.000087     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
   12              0.000024   endif
                            
   12   0.002621   0.000447   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  airline#extensions#tabline#tabs#map_keys()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/tabs.vim line 104
Called 12 times
Total time:   0.000813
 Self time:   0.000813

count  total (s)   self (s)
   12              0.000719   if maparg('<Plug>AirlineSelectTab1', 'n') is# ':1tabn<CR>'
   12              0.000037     return
                              endif
                              let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
                              if bidx_mode == 1
                                for i in range(1, 9)
                                  exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i, i)
                                endfor
                              else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i, i-10)
                                  endfor
                                endif
                              noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
                              noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim line 238
Called 12 times
Total time:   0.001175
 Self time:   0.000409

count  total (s)   self (s)
   12              0.000078   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
   12   0.000972   0.000206     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
   12              0.000033   endif

FUNCTION  <SNR>156_CheckDefined()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 132
Called 512 times
Total time:   0.079556
 Self time:   0.079556

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  512              0.009982   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  512              0.001470   endif
  512              0.005263   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  512              0.001173   endif
                            
 1292              0.007730   for val in a:colors
 1292              0.011051     if !empty(val) && val !=# 'NONE'
  512              0.001923       return a:colors
  780              0.002570     endif
  780              0.002485   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  307()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 41
Called 96 times
Total time:   0.148099
 Self time:   0.014586

count  total (s)   self (s)
   96   0.024234   0.001388   let title = self.get_title(a:index)
   96   0.112211   0.003228   let title_size = s:tabline_evaluated_length(title) + a:sep_size
   96              0.000511   if a:force || self._remaining_space >= title_size
   96              0.000415     let pos = a:pos
   96              0.000547     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
   96              0.000198     endif
                            
   96   0.003241   0.001557     call self.insert_section(a:group, title, pos)
   96              0.000415     let self._right_position += 1
   96              0.000322     let pos += 1
                            
   96              0.000481     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
   96              0.000225     endif
                            
   96              0.000424     let self._remaining_space -= title_size
   96              0.000271     return 1
                              endif
                              return 0

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/bundle/ale/autoload/ale/statusline.vim line 119
Called 16 times
Total time:   0.002052
 Self time:   0.000525

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   16   0.001972   0.000445     return copy(s:GetCounts(a:buffer))

FUNCTION  xolox#easytags#filetypes#canonicalize()
    Defined: ~/.vim/bundle/vim-easytags/autoload/xolox/easytags/filetypes.vim line 61
Called 7 times
Total time:   0.001882
 Self time:   0.001006

count  total (s)   self (s)
                              " Select a canonical, supported Vim file type given a value of &filetype.
    7   0.001317   0.000441   call s:discover_supported_filetypes()
                              " Split the possibly combined Vim file type into individual file types.
    8              0.000148   for filetype in split(tolower(a:vim_filetype_value), '\.')
                                " Canonicalize the Vim file type.
    7              0.000089     let filetype = get(s:canonical_filetypes, filetype, filetype)
    7              0.000113     if index(s:supported_filetypes, filetype) >= 0
    6              0.000022       return filetype
    1              0.000002     endif
    2              0.000006   endfor
    1              0.000004   return ''

FUNCTION  308()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 96
Called 12 times
Total time:   1.004329
 Self time:   0.024627

count  total (s)   self (s)
   12              0.000142   if has_key(self, '_left_position') && self._first_title <= self._last_title
   12   0.212667   0.000638     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
   12              0.000107     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
   12   0.002203   0.000379     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
   12   0.001880   0.000360     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
   12   0.000881   0.000413     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
   12   0.001162   0.000384     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
   12              0.000134     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
   12   0.001874   0.000279     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
   12              0.000050     if self._left_title > self._first_title
   12   0.015666   0.000347       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
   12              0.000022     endif
   12              0.000043     if self._left_title < self._last_title
   12   0.013935   0.000443       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
   12              0.000024     endif
                            
                                " Add the current title
   12   0.001950   0.000263     let group = self.get_group(self._left_title)
   12              0.000044     if self._left_title == self._first_title
                                  let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
   12              0.000026     else
   12   0.013929   0.000233       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
   12              0.000025     endif
   12              0.000046     if self._left_title == self._last_title
                                  let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
   12              0.000023     else
   12   0.017521   0.000309       let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
   12              0.000024     endif
   12              0.000042     let left_group = group
   12              0.000044     let right_group = group
   12   0.046419   0.000247     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
   12              0.000086     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
   12              0.000025     endif
                            
   12              0.000061     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
   12   0.000837   0.000173       let group = self.get_group(self._right_title)
   12              0.000039       if self._right_title == self._last_title
    2   0.007735   0.000057         let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
   10              0.000020       else
   10   0.023772   0.000223         let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
   12              0.000026       endif
   12              0.000047       let right_group = group
   12   0.018536   0.000243       let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
   12              0.000026     endif
                            
   84              0.000329     while self._remaining_space > 0
   84              0.000265       let done = 0
   84              0.000352       if self._left_title >= self._first_title
                                    " Insert next title to the left
   62   0.006118   0.000844         let group = self.get_group(self._left_title)
   62              0.000228         if self._left_title == self._first_title
   12   0.020739   0.000435           let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
   50              0.000130         else
   50   0.072618   0.001738           let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
   62              0.000141         endif
   62              0.000291         let left_group = group
   62   0.073153   0.001314         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
   62              0.000300         let self._left_title -= done
   84              0.000194       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
   84              0.000628       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
   10   0.001505   0.000282         let group = self.get_group(self._right_title)
   10              0.000035         if self._right_title == self._last_title
   10   0.025594   0.000364           let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
   10              0.000023         endif
   10              0.000039         let right_group = group
   10   0.011976   0.000181         let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
   10              0.000042         let self._right_title += done
   84              0.000202       endif
   84              0.000258       if !done
   12              0.000028         break
   72              0.000166       endif
   84              0.000291     endwhile
                            
   12              0.000042     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
   12              0.000028     endif
                            
   12              0.000042     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
   12              0.000026     endif
   12              0.000025   endif
                            
   12   0.397368   0.000187   return self._build()

FUNCTION  83()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim line 35
Called 720 times
Total time:   0.012738
 Self time:   0.012738

count  total (s)   self (s)
  720              0.004028     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
  720              0.001331     endif
  720              0.002025     return g:NERDTreeBookmarks

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/bundle/vim-fugitive/plugin/fugitive.vim line 250
Called 94 times
Total time:   0.002179
 Self time:   0.002179

count  total (s)   self (s)
   94              0.000615   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
   94              0.000239   else
   94              0.000309     return a:path
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim line 100
Called 16 times
Total time:   0.001432
 Self time:   0.001432

count  total (s)   self (s)
   16              0.001073     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   16              0.000245     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/fugitiveline.vim line 14
Called 57 times
Total time:   0.010211
 Self time:   0.009405

count  total (s)   self (s)
   57              0.000484   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
   57              0.000117   endif
                            
   57   0.002404   0.001598   let fmod = s:ModifierFlags()
   57              0.000277   if empty(b:fugitive_name)
   57              0.001873     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  <SNR>79_NERDTreeGetIndicator()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 183
Called 696 times
Total time:   0.032620
 Self time:   0.032620

count  total (s)   self (s)
  696              0.003869     if exists('g:NERDTreeIndicatorMapCustom')
                                    let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
                                    if l:indicator !=# ''
                                        return l:indicator
                                    endif
  696              0.001208     endif
  696              0.004777     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
  696              0.002164     if l:indicator !=# ''
    8              0.000040         return l:indicator
  688              0.001301     endif
  688              0.001536     return ''

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 72
Called 16 times
Total time:   0.018608
 Self time:   0.011996

count  total (s)   self (s)
   16              0.000231   if !exists(':ALELint')
                                return ''
   16              0.000040   endif
                            
   16              0.000140   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
   16              0.000116   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
   16              0.000113   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
   16              0.000113   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
   16              0.000078   let is_err = a:type ==# 'error'
                            
   16   0.001867   0.000435   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
   16              0.000081   endif
                            
   16              0.000097   let symbol = is_err ? error_symbol : warning_symbol
                            
   16   0.002452   0.000400   let counts = ale#statusline#Count(bufnr(''))
   16              0.000141   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
   16              0.000105     let errors = counts.error + counts.style_error
   16              0.000097     let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
   16              0.000040   endif
                            
   16              0.000060   if show_line_numbers == 1
   16   0.011449   0.008321     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/bundle/vim-fugitive/plugin/fugitive.vim line 11
Called 149 times
Total time:   0.013366
 Self time:   0.011241

count  total (s)   self (s)
  149              0.001158   if !a:0 || type(a:1) == type(0) && a:1 < 0
   55              0.000271     if exists('g:fugitive_event')
                                  return g:fugitive_event
   55              0.000128     endif
   55              0.000374     let dir = get(b:, 'git_dir', '')
   55              0.000596     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   55              0.000114     endif
   55              0.000165     return dir
   94              0.000482   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
   94              0.000487   elseif type(a:1) == type('')
   94   0.004502   0.002377     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim line 145
Called 12 times
Total time:   1.030668
 Self time:   0.002208

count  total (s)   self (s)
   12              0.000206   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   12              0.000189   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   12              0.000072   let curtabcnt = tabpagenr('$')
   12              0.000053   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
   12              0.000027   endif
                            
   12              0.000095   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
   12              0.000023   endif
   12              0.000037   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
   12              0.000033   elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
   12              0.000052   elseif show_buffers && curtabcnt == 1 || !show_tabs
                                return airline#extensions#tabline#buffers#get()
   12              0.000026   else
   12   1.028989   0.000529     return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/term.vim line 24
Called 8 times
Total time:   0.000617
 Self time:   0.000570

count  total (s)   self (s)
    8              0.000119   if getbufvar(a:2.bufnr, '&buftype') == 'terminal'
    2              0.000012     let spc = g:airline_symbols.space
    2   0.000094   0.000069     call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
    2   0.000045   0.000023     call a:1.add_section('airline_b', spc.'%f')
    2              0.000017     let neoterm_id = getbufvar(a:2.bufnr, 'neoterm_id')
    2              0.000008     if neoterm_id != ''
                                  call a:1.add_section('airline_c', spc.'neoterm_'.neoterm_id.spc)
    2              0.000004     endif
    2              0.000005     return 1
    6              0.000015   endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 37
Called 316 times
Total time:   0.013868
 Self time:   0.013868

count  total (s)   self (s)
  316              0.003857   let x = a:i - 1
  348              0.001316   while x >= 0
  312              0.002021     let group = a:sections[x][0]
  312              0.001513     if group != '' && group != '|'
  280              0.000889       return group
   32              0.000070     endif
   32              0.000132     let x = x - 1
   68              0.000172   endwhile
   36              0.000129   return ''

FUNCTION  airline#extensions#tabline#title()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim line 172
Called 192 times
Total time:   0.137250
 Self time:   0.038078

count  total (s)   self (s)
  192              0.000839   let title = ''
  192              0.000652   if s:taboo
                                let title = TabooTabTitle(a:n)
  192              0.000441   endif
                            
  192              0.002345   if empty(title) && exists('*gettabvar')
  192              0.002450     let title = gettabvar(a:n, 'title')
  192              0.000476   endif
                            
  192              0.000822   if empty(title)
  192              0.001773     let buflist = tabpagebuflist(a:n)
  192              0.001132     let winnr = tabpagewinnr(a:n)
  192   0.044347   0.005451     let all_buffers = airline#extensions#tabline#buflist#list()
  192   0.074858   0.014582     return airline#extensions#tabline#get_buffer_name( buflist[winnr - 1], filter(buflist, 'index(all_buffers, v:val) != -1'))
                              endif
                            
                              return title

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/hunks.vim line 45
Called 55 times
Total time:   0.015837
 Self time:   0.005977

count  total (s)   self (s)
   55              0.000504   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
   55              0.000109   endif
   55   0.012769   0.002909   return {b:source_func}()

FUNCTION  xolox#misc#msg#debug()
    Defined: ~/.vim/bundle/vim-misc/autoload/xolox/misc/msg.vim line 48
Called 44 times
Total time:   0.001619
 Self time:   0.001619

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
   44              0.000271   if &vbs >= 1
                                call s:show_message('Question', a:000)
   44              0.000103   endif

FUNCTION  <SNR>156_get_array()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 56
Called 1776 times
Total time:   0.054613
 Self time:   0.054613

count  total (s)   self (s)
 1776              0.016558   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 1776              0.028293   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 156
Called 4 times
Total time:   0.110655
 Self time:   0.001342

count  total (s)   self (s)
    4   0.000113   0.000075   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    4              0.000008   endif
   12              0.000048   for nr in a:range
    8   0.000383   0.000271     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
    8              0.000016     endif
    8              0.000076     call setwinvar(nr, 'airline_active', 0)
    8              0.000081     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    8              0.000062     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    8              0.000018     endif
    8   0.109455   0.000292     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   12              0.000037   endfor

FUNCTION  244()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 274
Called 8 times
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
    8              0.000075     return self._showHelp

FUNCTION  <SNR>158_get_hunks_gitgutter()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/hunks.vim line 26
Called 55 times
Total time:   0.009860
 Self time:   0.003107

count  total (s)   self (s)
   55   0.002946   0.001556   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    8              0.000025     return ''
   47              0.000099   endif
   47   0.006343   0.000980   return GitGutterGetHunkSummary()

FUNCTION  <SNR>115_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 198
Called 30 times
Total time:   0.014395
 Self time:   0.001571

count  total (s)   self (s)
   30   0.014271   0.001447   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 49
Called 12 times
Total time:   0.000778
 Self time:   0.000778

count  total (s)   self (s)
   12              0.000055   let x = a:i + 1
   12              0.000058   let l = len(a:sections)
   24              0.000073   while x < l
   24              0.000133     let group = a:sections[x][0]
   24              0.000080     if group != '' && group != '|'
   12              0.000036       return group
   12              0.000025     endif
   12              0.000044     let x = x + 1
   12              0.000033   endwhile
                              return ''

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 63
Called 55 times
Total time:   0.000607
 Self time:   0.000607

count  total (s)   self (s)
   55              0.000332   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim line 9
Called 15 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
   15              0.000071   return s:available

FUNCTION  airline#extensions#tabline#tabs#get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/tabs.vim line 28
Called 12 times
Total time:   1.028460
 Self time:   0.009334

count  total (s)   self (s)
   12              0.000152   let curbuf = bufnr('%')
   12              0.002097   let curtab = tabpagenr()
   12              0.000032   try
   12   0.001103   0.000290     call airline#extensions#tabline#tabs#map_keys()
                              catch
                                " no-op
   12              0.000035   endtry
   12              0.000084   if curbuf == s:current_bufnr && curtab == s:current_tabnr && &columns == s:column_width
    8              0.000077     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
                                  return s:current_tabline
    8              0.000016     endif
   12              0.000021   endif
                            
   12   0.004224   0.000380   let b = airline#extensions#tabline#new_builder()
                            
   12   0.001458   0.000283   call airline#extensions#tabline#add_label(b, 'tabs', 0)
                            
   12              0.000060   function! b.get_group(i) dict
                                let curtab = tabpagenr()
                                let group = 'airline_tab'
                                if a:i == curtab
                                  let group = 'airline_tabsel'
                                  if g:airline_detect_modified
                                    for bi in tabpagebuflist(curtab)
                                      if getbufvar(bi, '&modified')
                                        let group = 'airline_tabmod'
                                      endif
                                    endfor
                                  endif
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
   12              0.000043   function! b.get_title(i) dict
                                let val = '%('
                            
                                if get(g:, 'airline#extensions#tabline#show_tab_nr', 1)
                                  let tab_nr_type = get(g:, 'airline#extensions#tabline#tab_nr_type', 0)
                                  let val .= airline#extensions#tabline#tabs#tabnr_formatter(tab_nr_type, a:i)
                                endif
                            
                                return val.'%'.a:i.'T %{airline#extensions#tabline#title('.a:i.')} %)'
                              endfunction
                            
   12   0.001626   0.000222   call b.insert_titles(curtab, 1, tabpagenr('$'))
                            
   12   0.000417   0.000229   call b.add_section('airline_tabfill', '')
   12   0.000291   0.000104   call b.split()
   12   0.000285   0.000109   call b.add_section('airline_tabfill', '')
                            
   12              0.000073   if get(g:, 'airline#extensions#tabline#show_close_button', 1)
   12   0.000599   0.000310     call b.add_section('airline_tab_right', ' %999X'. get(g:, 'airline#extensions#tabline#close_symbol', 'X').' ')
   12              0.000029   endif
                            
   12              0.000091   if get(g:, 'airline#extensions#tabline#show_splits', 1) == 1
                                let buffers = tabpagebuflist(curtab)
                                for nr in buffers
                                  let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
                                  call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
                                endfor
                                if get(g:, 'airline#extensions#tabline#show_buffers', 1)
                                  call airline#extensions#tabline#add_label(b, 'buffers', 1)
                                endif
   12              0.000027   endif
   12   0.007281   0.000560   call airline#extensions#tabline#add_tab_label(b)
                            
   12              0.000146   let s:current_bufnr = curbuf
   12              0.000059   let s:current_tabnr = curtab
   12              0.001122   let s:column_width = &columns
   12   1.004694   0.000365   let s:current_tabline = b.build()
   12              0.000068   return s:current_tabline

FUNCTION  <SNR>87_init()
    Defined: ~/.vim/bundle/vim-airline/plugin/airline.vim line 12
Called 4 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    4              0.000018   if s:airline_initialized
    4              0.000012     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#extensions#wordcount#formatters#default#update_fmt()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim line 6
Called 4 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    4              0.000066   let s:fmt = get(g:, 'airline#extensions#wordcount#formatter#default#fmt', '%s words')
    4              0.000042   let s:fmt_short = get(g:, 'airline#extensions#wordcount#formatter#default#fmt_short', s:fmt == '%s words' ? '%sW' : s:fmt)

FUNCTION  airline#extensions#tabline#formatters#tabnr#format()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/formatters/tabnr.vim line 6
Called 96 times
Total time:   0.003246
 Self time:   0.003246

count  total (s)   self (s)
   96              0.000528   let spc=g:airline_symbols.space
   96              0.000377   if a:tab_nr_type == 0 " nr of splits
                                return spc. '%{len(tabpagebuflist('.a:nr.'))}'
   96              0.000332   elseif a:tab_nr_type == 1 " tab number
   96              0.000503     return spc. a:nr
                              else "== 2 splits and tab number
                                return spc. a:nr. '.%{len(tabpagebuflist('.a:nr.'))}'
                              endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 49
Called 110 times
Total time:   0.001568
 Self time:   0.001568

count  total (s)   self (s)
  110              0.000973   return get(s:parts, a:key, {})

FUNCTION  <SNR>162_airline_ale_count()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 6
Called 16 times
Total time:   0.002212
 Self time:   0.002212

count  total (s)   self (s)
   16              0.002131   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 127
Called 4 times
Total time:   0.284940
 Self time:   0.000771

count  total (s)   self (s)
    4   0.000142   0.000094   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    4              0.000009   endif
    4              0.000078   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.110791   0.000136   call airline#update_statusline_inactive(range)
                            
    4              0.000023   unlet! w:airline_render_left w:airline_render_right
    4              0.000085   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000044   let w:airline_active = 1
    4              0.000044   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.173638   0.000172   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 9
Called 45 times
Total time:   0.003048
 Self time:   0.003048

count  total (s)   self (s)
   45              0.000251   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   45              0.000335   let bvars = getbufvar(buffer, '')
   45              0.000178   if empty(bvars)
                                let bvars = {}
   45              0.000103   endif
   45              0.000274   let dict = get(bvars, 'gitgutter', {})
   45              0.000213   let needs_setting = empty(dict)
   45              0.000351   let dict[a:varname] = a:val
   45              0.000187   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
   45              0.000097   endif

FUNCTION  <SNR>152_invoke_funcrefs()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 177
Called 12 times
Total time:   0.282629
 Self time:   0.002007

count  total (s)   self (s)
   12   0.000957   0.000226   let builder = airline#builder#new(a:context)
   12   0.030577   0.000492   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   12              0.000037   if err == 1
   12   0.250030   0.000224     let a:context.line = builder.build()
   12              0.000409     let s:contexts[a:context.winnr] = a:context
   12              0.000127     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   12              0.000303     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   12              0.000032   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 104
Called 512 times
Total time:   0.610581
 Self time:   0.146476

count  total (s)   self (s)
  512              0.002854   if pumvisible()
                                return
  512              0.001369   endif
  512              0.002490   let colors = a:colors
  512              0.002959   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  512              0.001179   endif
  512   0.345731   0.016691   let old_hi = airline#highlighter#get_highlight(a:group)
  512              0.003016   if len(colors) == 4
  370              0.002211     call add(colors, '')
  512              0.004391   endif
  512              0.002756   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
  512              0.001195   else
  512              0.026438     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  512              0.001228   endif
  512   0.096811   0.017255   let colors = s:CheckDefined(colors)
  512   0.070862   0.015353   if old_hi != new_hi || !s:hl_group_exists(a:group)
                                let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                exe cmd
                                if has_key(s:hl_groups, a:group)
                                  let s:hl_groups[a:group] = colors
                                endif
  512              0.001186   endif

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim line 57
Called 8 times
Total time:   0.004171
 Self time:   0.003353

count  total (s)   self (s)
    8              0.000123   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    8              0.000107   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
    8              0.000020   endif
    8              0.000102   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
    8              0.000081   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
    8              0.000019   endif
    8   0.001134   0.000316   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  fugitive#Find()
    Defined: ~/.vim/bundle/vim-fugitive/autoload/fugitive.vim line 828
Called 94 times
Total time:   0.092498
 Self time:   0.058281

count  total (s)   self (s)
   94              0.000708   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
   94              0.001110   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
   94   0.005896   0.003891   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
   94   0.004532   0.002644   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
   94              0.000224   endif
   94              0.000677   let dir = a:0 ? a:1 : s:Dir()
   94              0.000427   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
   94              0.000237   endif
   94   0.003882   0.001859   let rev = s:Slash(a:object)
   94   0.020677   0.001470   let tree = s:Tree(dir)
   94              0.000562   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
   94              0.000327   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
   94              0.000724   elseif rev =~# '^\.git/'
   94              0.000876     let f = substitute(rev, '^\.git', '', '')
   94   0.008805   0.001890     let cdir = fugitive#CommonDir(dir)
   94              0.000814     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
   94              0.000616     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
   94              0.001379     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
   94              0.000196     else
   94              0.000648       let f = simplify(dir . f)
   94              0.000200     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^[^:.-][^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^[^:.-][^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit, '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
   94              0.000195   endif
   94   0.004109   0.001930   return FugitiveVimPath(f)

FUNCTION  <SNR>182_BufferCacheExists()
    Defined: ~/.vim/bundle/ale/autoload/ale/statusline.vim line 88
Called 16 times
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
   16              0.000200     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
   16              0.000054         return 0
                                endif
                            
                                return 1

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 67
Called 55 times
Total time:   0.004185
 Self time:   0.004185

count  total (s)   self (s)
   55              0.001317   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   55              0.000257   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   55              0.000127   endif
   55              0.000149   return ''

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/term.vim line 10
Called 4 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
    4              0.000044   if &buftype == 'terminal' || bufname('%')[0] == '!'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.s:section_a.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
    4              0.000008   endif

FUNCTION  <SNR>201_on_exit_vim()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim line 84
Called 15 times
Total time:   0.013489
 Self time:   0.013489

count  total (s)   self (s)
   15              0.000160   let job = ch_getjob(a:channel)
   15              0.000122   while 1
   15              0.012255     if job_status(job) == 'dead'
   15              0.000299       let exit_code = job_info(job).exitval
   15              0.000050       break
                                endif
                                sleep 5m
   15              0.000046   endwhile
                            
   15              0.000050   if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   15              0.000039   endif

FUNCTION  <SNR>86_Tlist_Get_File_Index()
    Defined: ~/.vim/bundle/taglist.vim/plugin/taglist.vim line 693
Called 2 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    2              0.000028     if s:tlist_file_count == 0 || a:fname == ''
                                    return -1
    2              0.000006     endif
                            
                                " If the new filename is same as the last accessed filename, then
                                " return that index
    2              0.000018     if s:tlist_file_name_idx_cache != -1 && s:tlist_file_name_idx_cache < s:tlist_file_count
    2              0.000028         if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
                                        " Same as the last accessed file
    2              0.000011             return s:tlist_file_name_idx_cache
                                    endif
                                endif
                            
                                " First, check whether the filename is present
                                let s_fname = a:fname . "\n"
                                let i = stridx(s:tlist_file_names, s_fname)
                                if i == -1
                                    let s:tlist_file_name_idx_cache = -1
                                    return -1
                                endif
                            
                                " Second, compute the file name index
                                let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
                                let s:tlist_file_name_idx_cache = strlen(nl_txt)
                                return s:tlist_file_name_idx_cache

FUNCTION  <SNR>156_exec_separator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 189
Called 370 times
Total time:   0.969181
 Self time:   0.075633

count  total (s)   self (s)
  370              0.003847   if pumvisible()
                                return
  370              0.000875   endif
  370              0.003440   let group = a:from.'_to_'.a:to.a:suffix
  370   0.249796   0.010253   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  370   0.298154   0.011555   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  370              0.004277   if a:inverse
  142              0.005353     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  228              0.000644   else
  228              0.002515     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  370              0.000830   endif
  370              0.007886   let a:dict[group] = colors
  370   0.377879   0.010473   call airline#highlighter#exec(group, colors)

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 12
Called 192 times
Total time:   0.046570
 Self time:   0.036177

count  total (s)   self (s)
  192              0.001521   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
  192              0.000662   let _ = ''
                            
  192              0.001757   let name = bufname(a:bufnr)
  192              0.000897   if empty(name)
                                let _ .= '[No Name]'
  192              0.000592   else
  192              0.000624     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Ð£Ñ‡Ñ‘Ð±Ð°/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
  192              0.001889       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
  192              0.000502     endif
  192              0.001969     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
  120              0.000824       let _ = strpart(_, 0, s:fnametruncate)
  192              0.000419     endif
  192              0.000421   endif
                            
  192   0.017588   0.007195   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 223
Called 55 times
Total time:   0.276450
 Self time:   0.008833

count  total (s)   self (s)
   55              0.000522   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   55              0.000126   endif
                            
   55   0.238475   0.001239   call s:update_branch()
   55   0.032321   0.002428   call s:update_untracked()
                            
   55              0.000504   if exists('b:airline_head') && !empty(b:airline_head)
   47              0.000171     return b:airline_head
    8              0.000019   endif
                            
    8              0.000066   let b:airline_head = ''
    8              0.000071   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    8              0.000028   let heads = []
   24              0.000088   for vcs in vcs_priority
   16              0.000104     if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
   16              0.000059     endif
   24              0.000070   endfor
                            
    8              0.000059   for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
    8              0.000027   endfor
                            
    8              0.000037   if empty(heads)
    8   0.000586   0.000208     if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
    8              0.000020     endif
    8              0.000019   endif
                            
    8              0.000037   if empty(heads)
    8   0.000311   0.000201     if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
    8              0.000015     endif
    8              0.000015   endif
                            
    8              0.000055   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  'â€¦' : '.')
                                endif
    8              0.000017   endif
                            
    8              0.000034   return b:airline_head

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 55
Called 55 times
Total time:   0.010105
 Self time:   0.002096

count  total (s)   self (s)
   55   0.009833   0.001824   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#tabline#buflist#invalidate()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buflist.vim line 6
Called 4 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
    4              0.000149   unlet! s:current_buffer_list

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/wordcount.vim line 88
Called 4 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
    4              0.000047   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000028   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000015   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    4              0.000007   endif
                            
    4              0.000022   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    4              0.000008   endif

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim line 107
Called 4 times
Total time:   0.000469
 Self time:   0.000304

count  total (s)   self (s)
    4              0.000077   if !g:gitgutter_map_keys
                                return
    4              0.000008   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    4              0.000029   let bufnr = bufnr('')
                            
    4   0.000243   0.000078   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    4              0.000009     return
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
                              endif
                            
                              call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>160_update_git_branch()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 86
Called 55 times
Total time:   0.216684
 Self time:   0.006874

count  total (s)   self (s)
   55   0.006062   0.001479   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
   55              0.000114   endif
                            
   55   0.205056   0.001452   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   55   0.002663   0.001040   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
   47              0.000323     let s:vcs_config['git'].branch='mas'
   55              0.000128   endif

FUNCTION  <SNR>201_on_stderr_vim()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim line 80
Called 30 times
Total time:   0.003447
 Self time:   0.000579

count  total (s)   self (s)
   30   0.003328   0.000460   call self.handler.err(self.buffer)

FUNCTION  <SNR>162_new_airline_ale_get_line_number()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 35
Called 16 times
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
   16              0.000060   if a:cnt == 0
   16              0.000046     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  indent_guides#clear_matches()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim line 75
Called 8 times
Total time:   0.003617
 Self time:   0.003260

count  total (s)   self (s)
    8   0.000589   0.000232   call indent_guides#init_matches()
    8              0.000050   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
    8              0.000020   endif

FUNCTION  airline#statusline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 190
Called 88 times
Total time:   0.003811
 Self time:   0.003811

count  total (s)   self (s)
   88              0.001623   if has_key(s:contexts, a:winnr)
   88              0.001498     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  lens#win_enter()
    Defined: ~/.vim/bundle/lens.vim/plugin/lens.vim line 131
Called 4 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
                              " Don't resize if the window is floating
    4              0.000047   if exists('*nvim_win_get_config')
                                if ! g:lens#resize_floating && nvim_win_get_config(0)['relative'] != ''
                                  return
                                endif
    4              0.000009   endif
                            
    4              0.000017   if g:lens#disabled || g:lens#enter_disabled
    4              0.000012     return
                              endif
                            
                              if index(g:lens#disabled_filetypes, &filetype) != -1
                                return
                              endif
                            
                              call lens#run()

FUNCTION  <SNR>175_setup_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim line 156
Called 15 times
Total time:   0.444484
 Self time:   0.001550

count  total (s)   self (s)
   15   0.001898   0.000339   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
   15   0.442414   0.001039   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 56
Called 17 times
Total time:   0.031130
 Self time:   0.001927

count  total (s)   self (s)
   17   0.031052   0.001849   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions.vim line 71
Called 10 times
Total time:   0.003796
 Self time:   0.002270

count  total (s)   self (s)
   10              0.000113   let filetype_overrides = get(s:, 'filetype_overrides', {})
   10              0.000104   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
   10   0.001763   0.000237   if s:is_excluded_window()
                                return -1
   10              0.000019   endif
                            
   10              0.000044   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
   10              0.000024   endif
                            
   10              0.000035   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   10              0.000024   endif
                            
   10              0.000164   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
   10              0.000023   endif
                            
   10              0.000037   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
   10              0.000020   endif
                            
   20              0.000143   for item in items(s:filetype_regex_overrides)
   10              0.000178     if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
   10              0.000025     endif
   20              0.000051   endfor

FUNCTION  <SNR>200_Slash()
    Defined: ~/.vim/bundle/vim-fugitive/autoload/fugitive.vim line 94
Called 282 times
Total time:   0.005916
 Self time:   0.005916

count  total (s)   self (s)
  282              0.001695   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  282              0.000613   else
  282              0.000929     return a:path
                              endif

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 131
Called 55 times
Total time:   0.004583
 Self time:   0.004583

count  total (s)   self (s)
   55              0.000694   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
   55              0.000322   endif
   55              0.002141   return s:has_fugitive

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 130
Called 502 times
Total time:   0.402509
 Self time:   0.034851

count  total (s)   self (s)
  502              0.002563   if a:group1 == a:group2
  240              0.000776     return 0
  262              0.000653   endif
  262   0.196493   0.010836   let color1 = airline#highlighter#get_highlight(a:group1)
  262   0.191030   0.009029   let color2 = airline#highlighter#get_highlight(a:group2)
  262              0.001169   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
  262              0.000574   else
  262              0.002386     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>86_Tlist_Get_Buffer_Filetype()
    Defined: ~/.vim/bundle/taglist.vim/plugin/taglist.vim line 983
Called 4 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
    4              0.000052     let buf_ft = getbufvar(a:bnum, '&filetype')
                            
    4              0.000503     if bufloaded(a:bnum)
                                    " For loaded buffers, the 'filetype' is already determined
                                    return buf_ft
    4              0.000009     endif
                            
                                " For unloaded buffers, if the 'filetype' option is set, return it
    4              0.000018     if buf_ft != ''
    4              0.000012         return buf_ft
                                endif
                            
                                " Skip non-existent buffers
                                if !bufexists(a:bnum)
                                    return ''
                                endif
                            
                                " For buffers whose filetype is not yet determined, try to determine
                                " the filetype
                                let bname = bufname(a:bnum)
                            
                                return s:Tlist_Detect_Filetype(bname)

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 27
Called 118 times
Total time:   0.014123
 Self time:   0.007534

count  total (s)   self (s)
  118   0.009578   0.002989   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
  118              0.000284   else
  118              0.000675     return a:text
                              endif

FUNCTION  <SNR>162_ale_refresh()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 125
Called 11 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   11              0.000114   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
   11              0.000026   endif

FUNCTION  xolox#misc#option#get()
    Defined: ~/.vim/bundle/vim-misc/autoload/xolox/misc/option.vim line 7
Called 14 times
Total time:   0.000857
 Self time:   0.000857

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
   14              0.000115   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
   14              0.000086   elseif exists('g:' . a:name)
                                " Global variable.
    7              0.000051     return eval('g:' . a:name)
    7              0.000029   elseif exists('a:1')
                                " Default value.
    7              0.000022     return a:1
                              endif

FUNCTION  xolox#easytags#autoload()
    Defined: ~/.vim/bundle/vim-easytags/autoload/xolox/easytags.vim line 130
Called 7 times
Total time:   0.004903
 Self time:   0.002075

count  total (s)   self (s)
    7              0.000032   try
    7   0.000268   0.000179     let session_loading = xolox#easytags#session_is_loading() && a:event == 'BufReadPost'
    7   0.000619   0.000165     let do_update = xolox#misc#option#get('easytags_auto_update', 1) && !session_loading
    7   0.000544   0.000141     let do_highlight = xolox#misc#option#get('easytags_auto_highlight', 1) && &eventignore !~? '\<syntax\>'
                                " Don't execute this function for unsupported file types (doesn't load
                                " the list of file types if updates and highlighting are both disabled).
    7   0.002390   0.000508     if (do_update || do_highlight) && !empty(xolox#easytags#filetypes#canonicalize(&filetype))
                                  " Update entries for current file in tags file?
    6              0.000021       if do_update
    6              0.000122         let buffer_read = (a:event =~? 'BufReadPost')
    6              0.000082         let buffer_written = (a:event =~? 'BufWritePost')
    6              0.000042         if buffer_written || (buffer_read && xolox#misc#option#get('easytags_always_enabled', 0))
                                      call xolox#easytags#update(1, 0, [])
    6              0.000017         endif
    6              0.000013       endif
                                  " Apply highlighting of tags to current buffer?
    6              0.000019       if do_highlight
                                    if !exists('b:easytags_last_highlighted')
                                      call xolox#easytags#highlight()
                                    else
                                      for tagfile in tagfiles()
                                        if getftime(tagfile) > b:easytags_last_highlighted
                                          call xolox#easytags#highlight()
                                          break
                                        endif
                                      endfor
                                    endif
                                    let b:easytags_last_highlighted = localtime()
    6              0.000013       endif
    7              0.000016     endif
                              catch
                                call xolox#misc#msg#warn("easytags.vim %s: %s (at %s)", g:xolox#easytags#version, v:exception, v:throwpoint)
    7              0.000027   endtry

FUNCTION  <SNR>115_abs_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 193
Called 75 times
Total time:   0.028154
 Self time:   0.028154

count  total (s)   self (s)
   75              0.027180   let p = resolve(expand('#'.a:bufnr.':p'))
   75              0.000636   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  indent_guides#process_autocmds()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim line 21
Called 8 times
Total time:   0.004371
 Self time:   0.000363

count  total (s)   self (s)
    8              0.000050   if g:indent_guides_autocmds_enabled
                                call indent_guides#enable()
    8              0.000019   else
    8   0.004169   0.000161     call indent_guides#disable()
    8              0.000017   end

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 24
Called 83 times
Total time:   0.005623
 Self time:   0.005623

count  total (s)   self (s)
   83              0.000760   let bvars = getbufvar(a:buffer, '')
   83              0.000351   if !empty(bvars)
   83              0.000636     let dict = get(bvars, 'gitgutter', {})
   83              0.000956     if has_key(dict, a:varname)
   19              0.000089       return dict[a:varname]
   64              0.000148     endif
   64              0.000128   endif
   64              0.000353   if a:0
   64              0.000460     return a:1
                              endif

FUNCTION  <SNR>178_tabline_evaluated_length()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 223
Called 144 times
Total time:   0.123807
 Self time:   0.006242

count  total (s)   self (s)
  144   0.123338   0.005773   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 62
Called 220 times
Total time:   0.005964
 Self time:   0.005964

count  total (s)   self (s)
  220              0.001286   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  220              0.000496   endif
  220              0.001790   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  airline#util#has_vcscommand()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 145
Called 8 times
Total time:   0.000378
 Self time:   0.000378

count  total (s)   self (s)
    8              0.000112   if !exists("s:has_vcscommand")
                                let s:has_vcscommand = exists('*VCSCommandGetStatusLine')
    8              0.000020   endif
    8              0.000057   return get(g:, 'airline#extensions#branch#use_vcscommand', 0) && s:has_vcscommand

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim line 103
Called 48 times
Total time:   0.012280
 Self time:   0.007863

count  total (s)   self (s)
   48              0.000524     let l:buffer = bufnr('')
                            
   48              0.000224     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   48              0.000144     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   48              0.000288     if mode(1) isnot# 'n'
                                    return
   48              0.000104     endif
                            
   48   0.003580   0.001296     call s:StopCursorTimer()
                            
   48              0.000563     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   48              0.000239     if l:pos != s:last_pos
   29   0.002610   0.000477         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
   29              0.000217         let s:last_pos = l:pos
   29              0.001369         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
   48              0.000110     endif

FUNCTION  <SNR>87_on_cursor_moved()
    Defined: ~/.vim/bundle/vim-airline/plugin/airline.vim line 74
Called 37 times
Total time:   0.002351
 Self time:   0.001654

count  total (s)   self (s)
   37              0.000351   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   37              0.000078   endif
   37   0.001488   0.000791   call airline#update_tabline()

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 107
Called 8 times
Total time:   0.014438
 Self time:   0.000305

count  total (s)   self (s)
    8   0.014397   0.000264   return airline#extensions#ale#get('warning')

FUNCTION  airline#extensions#vista#currenttag()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/vista.vim line 6
Called 55 times
Total time:   0.000989
 Self time:   0.000989

count  total (s)   self (s)
   55              0.000403   if get(w:, 'airline_active', 0)
   55              0.000328     return get(b:, 'vista_nearest_method_or_function', '')
                              endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 81
Called 12 times
Total time:   0.030085
 Self time:   0.004782

count  total (s)   self (s)
   60              0.000256     for Fn in a:list
   60   0.027939   0.002636       let code = call(Fn, a:000)
   60              0.000214       if code != 0
   12              0.000037         return code
   48              0.000104       endif
   48              0.000116     endfor
                                return 0

FUNCTION  237()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 25
Called 8 times
Total time:   0.002982
 Self time:   0.002692

count  total (s)   self (s)
    8   0.000293   0.000120     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapPreview .": preview file\n"
                                    let help .= "\" ". g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    8   0.000258   0.000141     elseif !self.isMinimal()
    8              0.000048         let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
    8              0.000091         silent! put =help
    8              0.000015     endif

FUNCTION  <SNR>158_is_branch_empty()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/hunks.vim line 21
Called 55 times
Total time:   0.001390
 Self time:   0.001390

count  total (s)   self (s)
   55              0.001025   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>115_unc_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 175
Called 15 times
Total time:   0.005785
 Self time:   0.000486

count  total (s)   self (s)
   15   0.005747   0.000448   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>79_NERDTreeCacheDirtyDir()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 126
Called 7 times
Total time:   0.001016
 Self time:   0.000674

count  total (s)   self (s)
                                " cache dirty dir
    7   0.000507   0.000165     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
    7              0.000059     if l:dirtyPath =~# '\.\./.*'
                                    return
    7              0.000015     endif
    7              0.000094     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
    7              0.000146     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
                                    let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
                                    let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
    7              0.000023     endwhile

FUNCTION  <SNR>7_switch()
    Defined: ~/.vimrc line 1006
Called 4 times
Total time:   0.542769
 Self time:   0.001012

count  total (s)   self (s)
    4              0.000048   if tabpagenr("$") > 1
    4   0.542549   0.000792     exe "tabnext" g:lasttab
                              else
                                "without this, any change in a buffer will 
                                "generate a warning before switch to other buffer
                                set hidden
                                b #
    4              0.000027   endif

FUNCTION  airline#util#append()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 48
Called 385 times
Total time:   0.012955
 Self time:   0.012955

count  total (s)   self (s)
  385              0.002325   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  385              0.000943   endif
  385              0.002997   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  385              0.002448   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>201_build_command()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim line 40
Called 15 times
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
   15              0.000128   if has('unix')
   15              0.000067     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/themes.vim line 31
Called 740 times
Total time:   0.526142
 Self time:   0.027588

count  total (s)   self (s)
  740   0.523875   0.025321   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>160_update_branch()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 157
Called 55 times
Total time:   0.237236
 Self time:   0.010824

count  total (s)   self (s)
  165              0.001030   for vcs in keys(s:vcs_config)
  110   0.231486   0.005074     call {s:vcs_config[vcs].update_branch}()
  110              0.001051     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  110              0.000241     endif
  165              0.000460   endfor

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim line 72
Called 4 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    4              0.000027     if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
    4              0.000011     else
    4              0.000027         for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
    4              0.000012         endfor
    4              0.000009     endif

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/bundle/vim-fugitive/plugin/fugitive.vim line 133
Called 94 times
Total time:   0.016776
 Self time:   0.003223

count  total (s)   self (s)
   94   0.016484   0.002931   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>160_update_untracked()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 176
Called 55 times
Total time:   0.029893
 Self time:   0.029578

count  total (s)   self (s)
   55              0.011321   let file = expand("%:p")
   55              0.007626   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   55              0.000126   endif
                            
   55              0.000254   let needs_update = 1
   55              0.000484   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  165              0.000777   for vcs in keys(s:vcs_config)
  110              0.001047     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
   47              0.000170       let needs_update = 0
  110              0.000228     endif
  110              0.001012     if has_key(s:vcs_config[vcs].untracked, file)
    8              0.000035       let needs_update = 0
    8   0.000575   0.000260       call airline#extensions#branch#update_untracked_config(file, vcs)
  110              0.000223     endif
  165              0.000435   endfor
                            
   55              0.000177   if !needs_update
   55              0.000148     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && !airline#util#has_fugitive()
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  airline#util#has_custom_scm()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 152
Called 8 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    8              0.000074   return !empty(get(g:, 'airline#extensions#branch#custom_head', ''))

FUNCTION  <SNR>114_on_bufenter()
    Defined: ~/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim line 212
Called 4 times
Total time:   0.223908
 Self time:   0.000529

count  total (s)   self (s)
    4   0.000582   0.000113   call gitgutter#setup_maps()
                            
    4              0.000033   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
    4              0.000018     let t:gitgutter_didtabenter = 0
    4   0.223130   0.000220     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
                                call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    4              0.000011   endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 145
Called 15 times
Total time:   0.441375
 Self time:   0.006696

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
   15   0.001316   0.000338   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
   15   0.023523   0.002491   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
   15   0.000818   0.000700   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
   15              0.000279     let handler = copy(s:set_path_handler)
   15              0.000091     let handler.continuation = a:continuation
   15   0.414598   0.002047     call gitgutter#async#execute(cmd, a:bufnr, handler)
   15              0.000179     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  NERDTreeGetGitStatusPrefix()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 150
Called 696 times
Total time:   3.110509
 Self time:   0.135076

count  total (s)   self (s)
  696              0.008122     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
    7              0.000075         let s:GitStatusCacheTime = localtime()
    7   2.529471   0.000361         call g:NERDTreeGitStatusRefresh()
  696              0.001332     endif
  696   0.195674   0.006875     let l:pathStr = a:path.str()
  696   0.231717   0.016427     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
  696   0.020537   0.010923     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
  696              0.001386     endif
  696              0.008741     let l:cwd = substitute(l:cwd, '\~', '\\~', 'g')
  696              0.022153     let l:pathStr = substitute(l:pathStr, l:cwd, '', '')
  696              0.002439     let l:statusKey = ''
  696              0.002275     if a:path.isDirectory
    8              0.000232         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
  688              0.001415     else
  688              0.009829         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
  696              0.002170     endif
  696   0.046610   0.013990     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  <SNR>178_get_separator_change()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 68
Called 108 times
Total time:   0.154148
 Self time:   0.004362

count  total (s)   self (s)
  108   0.153517   0.003731   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim line 136
Called 4 times
Total time:   0.001882
 Self time:   0.001677

count  total (s)   self (s)
    4              0.000092     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    4   0.000504   0.000299     call ale#highlight#RemoveHighlights()
                            
    4              0.000019     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
    4              0.000112     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    4              0.000460     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    4              0.000012     endif

FUNCTION  <SNR>7_TabWinEnter()
    Defined: ~/.vimrc line 4458
Called 4 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    4              0.000032     if exists('t:tab_name')
                                    call setwinvar(winnr(), "tab_win_name", t:tab_name)
    4              0.000011     endif

FUNCTION  <SNR>179_ExcludeOther()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buflist.vim line 28
Called 48 times
Total time:   0.002405
 Self time:   0.002405

count  total (s)   self (s)
   48              0.000842   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
   48              0.001350     return 1 | endif

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/buflist.vim line 35
Called 192 times
Total time:   0.038896
 Self time:   0.030046

count  total (s)   self (s)
  192              0.001383   if exists('s:current_buffer_list')
  188              0.000742     return s:current_buffer_list
    4              0.000008   endif
                            
    4              0.000030   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    4              0.000022   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    4              0.000024   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    4              0.000056   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    4              0.000012   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
  152              0.000501   for nr in list
  148              0.000925     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
   52              0.000307       if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
   52              0.001378       elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
   52   0.007641   0.001196       elseif airline#util#ignore_buf(bufname(nr))
    4              0.000024         continue
                                  " check other types last
   48   0.004466   0.002061       elseif s:ExcludeOther(nr, exclude_preview)
    4              0.000012         continue
   44              0.000098       endif
                            
   44              0.000286       call add(buffers, nr)
  140              0.000313     endif
  144              0.000355   endfor
                            
    4              0.000063   let s:current_buffer_list = buffers
    4              0.000014   return buffers

FUNCTION  13()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 288
Called 688 times
Total time:   0.011712
 Self time:   0.011712

count  total (s)   self (s)
  688              0.002188     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
  688              0.001251     endif
                            
  688              0.001815     return self.cachedDisplayString

FUNCTION  <SNR>86_Tlist_Log_Msg()
    Defined: ~/.vim/bundle/taglist.vim/plugin/taglist.vim line 660
Called 4 times
Total time:   0.000317
 Self time:   0.000317

count  total (s)   self (s)
    4              0.000079     if s:tlist_debug
                                    if s:tlist_debug_file != ''
                                        exe 'redir >> ' . s:tlist_debug_file
                                        silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
                                        redir END
                                    else
                                        " Log the message into a variable
                                        " Retain only the last 3000 characters
                                        let len = strlen(s:tlist_msg)
                                        if len > 3000
                                            let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
                                        endif
                                        let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' .  a:msg . "\n"
                                    endif
    4              0.000010     endif

FUNCTION  101()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim line 287
Called 8 times
Total time:   0.021647
 Self time:   0.002548

count  total (s)   self (s)
    8   0.021572   0.002473     call sort(s:Bookmark.Bookmarks(), s:Bookmark.CompareBookmarksByName, s:Bookmark)

FUNCTION  102()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim line 293
Called 184 times
Total time:   0.133274
 Self time:   0.076549

count  total (s)   self (s)
  184   0.028758   0.002940     let pathStrMaxLen = winwidth(g:NERDTree.GetWinNum()) - 4 - strdisplaywidth(self.name)
  184              0.001022     if &nu
                                    let pathStrMaxLen = pathStrMaxLen - &numberwidth
  184              0.000378     endif
                            
  184   0.033199   0.002292     let pathStr = self.path.str({'format': 'UI'})
  184              0.001068     if strdisplaywidth(pathStr) > pathStrMaxLen
 3248              0.022332         while strdisplaywidth(pathStr) > pathStrMaxLen && strchars(pathStr) > 0
 3112              0.023207             let pathStr = substitute(pathStr, '^.', '', '')
 3248              0.007580         endwhile
  136              0.000524         let pathStr = '<' . pathStr
  184              0.000420     endif
  184              0.000812     return '>' . self.name . ' ' . pathStr

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim line 32
Called 9 times
Total time:   0.007786
 Self time:   0.006882

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    9              0.000091     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
    9              0.000019     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    9              0.000063     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
    9              0.000016     endif
                            
    9              0.000073     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    9              0.000032     if l:filetype is# ''
                                    return 1
    9              0.000018     endif
                            
                                " Do nothing for diff buffers.
    9              0.000053     if getbufvar(a:buffer, '&diff')
                                    return 1
    9              0.000019     endif
                            
                                " Do nothing for blacklisted files.
    9              0.000125     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
    9              0.000017     endif
                            
                                " Do nothing if running from command mode.
    9              0.000077     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
    9              0.000017     endif
                            
    9              0.000180     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    9              0.000032     if l:filename is# '.'
                                    return 1
    9              0.000016     endif
                            
                                " Don't start linting and so on when an operator is pending.
    9   0.000319   0.000163     if ale#util#Mode(1) is# 'no'
                                    return 1
    9              0.000016     endif
                            
                                " Do nothing if running in the sandbox.
    9   0.000668   0.000178     if ale#util#InSandbox()
                                    return 1
    9              0.000016     endif
                            
                                " Do nothing if the file is too large.
    9   0.000400   0.000142     if ale#FileTooLarge(a:buffer)
                                    return 1
    9              0.000024     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    9              0.002064     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
    9              0.000070     endif
                            
    9              0.000658     return 0

FUNCTION  <SNR>200_Tree()
    Defined: ~/.vim/bundle/vim-fugitive/autoload/fugitive.vim line 308
Called 94 times
Total time:   0.019207
 Self time:   0.002431

count  total (s)   self (s)
   94   0.018708   0.001932   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  20()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 372
Called 3448 times
Total time:   0.107859
 Self time:   0.107859

count  total (s)   self (s)
 3448              0.014532     if empty(self.pathSegments)
                                    return ''
 3448              0.006410     endif
 3448              0.016741     let toReturn = self.pathSegments[-1]
 3448              0.010921     if a:dirSlash && self.isDirectory
    8              0.000134         let toReturn = toReturn . '/'
 3448              0.006075     endif
 3448              0.009238     return toReturn

FUNCTION  25()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 473
Called 1376 times
Total time:   0.059394
 Self time:   0.018161

count  total (s)   self (s)
 1376   0.056206   0.014973     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  27()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 494
Called 1376 times
Total time:   0.393059
 Self time:   0.162705

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 1376   0.018596   0.010632     if a:nerdtree.ui.isIgnoreFilterEnabled()
 2752              0.008359         for i in g:NERDTreeIgnore
 1376   0.136045   0.011492             if self._ignorePatternMatches(i)
                                            return 1
 1376              0.002501             endif
 2752              0.005707         endfor
                            
 1376   0.036030   0.011933         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
 1376              0.003076         endfor
 1376              0.002529     endif
                            
                                "dont show hidden files unless instructed to
 1376   0.083867   0.017314     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
 1376              0.002611     endif
                            
 1376   0.020928   0.013741     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
 1376              0.002451     endif
                            
 1376              0.003135     return 0

FUNCTION  28()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 524
Called 1376 times
Total time:   0.124553
 Self time:   0.081915

count  total (s)   self (s)
 1376              0.005253     let pat = a:pattern
 1376              0.008780     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
 1376              0.008262     elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
 1376              0.003062     endif
                            
 1376   0.058093   0.015455     return self.getLastPathComponent(0) =~# pat

FUNCTION  <SNR>160_update_hg_branch()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 122
Called 55 times
Total time:   0.009728
 Self time:   0.008151

count  total (s)   self (s)
   55   0.002549   0.000972   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   55              0.000119   else
   55              0.000296     let s:vcs_config['mercurial'].branch = ''
   55              0.000168   endif

FUNCTION  xolox#misc#async#periodic_callback()
    Defined: ~/.vim/bundle/vim-misc/autoload/xolox/misc/async.vim line 224
Called 10 times
Total time:   0.001405
 Self time:   0.001405

count  total (s)   self (s)
                              " When client/server support is not being used the vim-misc plug-in
                              " improvises: It uses Vim's [CursorHold][] event to periodically check if an
                              " asynchronous process has written its results to one of the expected
                              " temporary files. If a response is found the temporary file is read and
                              " deleted and then `xolox#misc#async#callback_to_parent()` is called to
                              " process the response.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
   10              0.000124   if !empty(g:xolox#misc#async#requests)
                                let num_processed = 0
                                call xolox#misc#msg#debug("vim-misc %s: Checking for asynchronous responses (%i responses not yet received) ..", g:xolox#misc#version, len(g:xolox#misc#async#requests))
                                for unique_number in sort(keys(g:xolox#misc#async#requests))
                                  let request = g:xolox#misc#async#requests[unique_number]
                                  let temporary_file = get(request, 'temporary_file', '')
                                  if !empty(temporary_file) && getfsize(temporary_file) > 0
                                    try
                                      call xolox#misc#msg#debug("vim-misc %s: Found asynchronous response by %s in %s ..", g:xolox#misc#version, request['function'], temporary_file)
                                      call xolox#misc#async#callback_to_parent(xolox#misc#persist#load(temporary_file))
                                      let num_processed += 1
                                    finally
                                      call delete(temporary_file)
                                    endtry
                                  endif
                                endfor
                                call xolox#misc#msg#debug("vim-misc %s: Processed %i asynchronous responses (%i responses not yet received).", g:xolox#misc#version, num_processed, len(g:xolox#misc#async#requests))
   10              0.000021   endif

FUNCTION  117()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim line 157
Called 2072 times
Total time:   0.011747
 Self time:   0.011747

count  total (s)   self (s)
 2072              0.006446     return self._nerdtree

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 18
Called 623 times
Total time:   0.023382
 Self time:   0.023382

count  total (s)   self (s)
  623              0.005647   let nr = get(a:000, 0, 0)
  623              0.004194   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  623              0.001492   else
  623              0.004617     return winwidth(nr)
                              endif

FUNCTION  <SNR>156_hl_group_exists()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 95
Called 512 times
Total time:   0.055509
 Self time:   0.055509

count  total (s)   self (s)
  512              0.025047   if !hlexists(a:group)
                                return 0
  512              0.016508   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  512              0.001365   endif
  512              0.001404   return 1

FUNCTION  32()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 583
Called 16192 times
Total time:   9.090882
 Self time:   0.692755

count  total (s)   self (s)
16192   0.468051   0.229051     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
16192              0.034209     else
16192   8.440443   0.281316         return self.str() ==# a:path.str()
                                endif

FUNCTION  38()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 692
Called 696 times
Total time:  12.888400
 Self time:   0.021478

count  total (s)   self (s)
  696   3.284477   0.011110     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
  696   9.601023   0.007468     call self.cacheDisplayString()

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim line 71
Called 4 times
Total time:   0.000714
 Self time:   0.000714

count  total (s)   self (s)
    4              0.000677     if !isdirectory(a:dir)
    4              0.000017         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  40()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 742
Called 33985 times
Total time:   8.575139
 Self time:   4.214883

count  total (s)   self (s)
33985              0.152873     let options = a:0 ? a:1 : {}
33985              0.102465     let toReturn = ""
                            
33985              0.143100     if has_key(options, 'format')
  192              0.000701         let format = options['format']
  192              0.000910         if has_key(self, '_strFor' . format)
  192   0.007437   0.002385             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
  192              0.000369         endif
33793              0.064612     else
33793   4.376635   0.322738         let toReturn = self._str()
33985              0.075220     endif
                            
33985   0.773754   0.472447     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
33985              0.067357     endif
                            
33985              0.133003     if has_key(options, 'truncateTo')
    8              0.000029         let limit = options['truncateTo']
    8              0.000061         if strdisplaywidth(toReturn) > limit-1
  392              0.002852             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
  384              0.002287                 let toReturn = substitute(toReturn, '^.', '', '')
  392              0.000826             endwhile
    8              0.000068             if len(split(toReturn, '/')) > 1
    8              0.000084                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
    8              0.000013             endif
    8              0.000012         endif
33985              0.062001     endif
                            
33985              0.097693     return toReturn

FUNCTION  41()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 779
Called 192 times
Total time:   0.005052
 Self time:   0.005052

count  total (s)   self (s)
  192              0.001463     let toReturn = '/' . join(self.pathSegments, '/')
  192              0.000718     if self.isDirectory && toReturn != '/'
  192              0.000632         let toReturn  = toReturn . '/'
  192              0.000347     endif
  192              0.000519     return toReturn

FUNCTION  45()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 837
Called 33793 times
Total time:   4.053897
 Self time:   1.772761

count  total (s)   self (s)
33793   2.121728   0.333344     let l:separator = s:Path.Slash()
33793              0.132367     let l:leader = l:separator
                            
33793   0.990121   0.497369     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
33793              0.069988     endif
                            
33793              0.283200     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  130()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim line 288
Called 688 times
Total time:  10.578392
 Self time:   0.018256

count  total (s)   self (s)
  688  10.576353   0.016217     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  132()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim line 310
Called 8 times
Total time:   0.679779
 Self time:   0.000207

count  total (s)   self (s)
    8   0.679758   0.000186     return self._renderToString(0, 0)

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 67
Called 1776 times
Total time:   1.195252
 Self time:   0.585581

count  total (s)   self (s)
 1776              0.230660   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1776              0.018042   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 1776              0.005481   else
 1776   0.315286   0.048019     let fg = s:get_syn(a:group, 'fg')
 1776   0.327027   0.039236     let bg = s:get_syn(a:group, 'bg')
 1776              0.059668     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 1776              0.006011     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
 1776              0.004448     else
 1776   0.107107   0.052494       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
 1776              0.005272     endif
 1776              0.005100   endif
 1776              0.030883   let s:hl_groups[a:group] = res
 1776              0.009086   return res

FUNCTION  voom#BodyBufEnter()
    Defined: ~/.vim/bundle/VOoM/autoload/voom.vim line 2392
Called 2 times
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
                            " Body BufEnter au. Restore buffer-local mappings lost after :bd.
    2              0.000186     if !hasmapto('voom#ToTreeOrBodyWin','n')
                                    call voom#BodyMap()
    2              0.000005     endif

FUNCTION  <SNR>173_get_accented_line()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 166
Called 270 times
Total time:   0.041413
 Self time:   0.041413

count  total (s)   self (s)
  270              0.001321   if a:self._context.active
                                " active window
  244              0.008197     let contents = []
  244              0.004047     let content_parts = split(a:contents, '__accent')
  454              0.001811     for cpart in content_parts
  210              0.003521       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  210              0.001312       call add(contents, cpart)
  454              0.001233     endfor
  244              0.001737     let line = join(contents, a:group)
  244              0.003052     let line = substitute(line, '__restore__', a:group, 'g')
   26              0.000060   else
                                " inactive window
   26              0.000541     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   26              0.000326     let line = substitute(line, '%#__restore__#', '', 'g')
  270              0.000635   endif
  270              0.000979   return line

FUNCTION  152()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim line 363
Called 16 times
Total time:   0.443506
 Self time:   0.043210

count  total (s)   self (s)
   16              0.000050     let toReturn = []
 1392              0.004092     for i in self.children
 1376   0.418947   0.018651         if i.path.ignore(self.getNerdtree()) ==# 0
 1376              0.006673             call add(toReturn, i)
 1376              0.003272         endif
 1392              0.003011     endfor
   16              0.000035     return toReturn

FUNCTION  154()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim line 385
Called 8 times
Total time:   0.324229
 Self time:   0.004870

count  total (s)   self (s)
    8              0.000035     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
    8              0.000014     endif
                            
    8              0.000030     if self.path.isSymLink
                                    return 0
    8              0.000015     endif
                            
  192   0.000731   0.000596     for i in g:NERDTreeBookmark.Bookmarks()
  184   0.096576   0.001740         if i.path.equals(self.path)
                                        return 0
  184              0.000359         endif
  192              0.000508     endfor
                            
    8   0.224477   0.000089     let c = self.getVisibleChildren()
    8              0.000031     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim line 79
Called 10 times
Total time:   0.018816
 Self time:   0.002124

count  total (s)   self (s)
   10              0.000059   let winnr = a:context.winnr
   10              0.000053   let active = a:context.active
                            
   10   0.000407   0.000287   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    6   0.004755   0.000136     call s:build_sections(a:builder, a:context, s:layout[0])
    4              0.000010   else
    4   0.001594   0.000072     let text = s:get_section(winnr, 'c')
    4              0.000016     if empty(text)
                                  let text = ' %f%m '
    4              0.000008     endif
    4   0.000260   0.000193     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   10              0.000025   endif
                            
   10   0.001607   0.000312   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   10   0.000341   0.000249   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    8   0.009164   0.000187     call s:build_sections(a:builder, a:context, s:layout[1])
   10              0.000082   endif
                            
   10              0.000032   return 1

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim line 24
Called 9 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
    9              0.000126     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    9              0.000062     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  NERDTreeRender()
    Defined: ~/.vim/bundle/nerdtree/plugin/NERD_tree.vim line 212
Called 8 times
Total time:   0.859891
 Self time:   0.000195

count  total (s)   self (s)
    8   0.859821   0.000125     call nerdtree#renderView()

FUNCTION  164()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim line 597
Called 8 times
Total time:  12.933103
 Self time:   0.021937

count  total (s)   self (s)
    8   2.333132   0.000358     call self.path.refreshFlags(self.getNerdtree())
  696              0.008169     for i in self.children
  688  10.587646   0.009254         call i.refreshFlags()
  696              0.001657     endfor

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 220
Called 162 times
Total time:   0.382349
 Self time:   0.012168

count  total (s)   self (s)
  162              0.004112   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  162   0.377464   0.007283   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>140_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim81/plugin/matchparen.vim line 39
Called 41 times
Total time:   0.014255
 Self time:   0.014255

count  total (s)   self (s)
                              " Remove any previous match.
   41              0.000320   if exists('w:paren_hl_on') && w:paren_hl_on
    1              0.000006     silent! call matchdelete(3)
    1              0.000004     let w:paren_hl_on = 0
   41              0.000083   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   41              0.000297   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   41              0.000083   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   41              0.000209   let c_lnum = line('.')
   41              0.000213   let c_col = col('.')
   41              0.000248   let before = 0
                            
   41              0.000209   let text = getline(c_lnum)
   41              0.002962   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   41              0.000999   if empty(matches)
                                let [c_before, c] = ['', '']
   41              0.001704   else
   41              0.000406     let [c_before, c] = matches[1:2]
   41              0.000087   endif
   41              0.001053   let plist = split(&matchpairs, '.\zs[:,]')
   41              0.000261   let i = index(plist, c)
   41              0.000118   if i < 0
                                " not found, in Insert mode try character before the cursor
   40              0.000233     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   40              0.000085     endif
   40              0.000098     if i < 0
                                  " not found, nothing to do
   40              0.000103       return
                                endif
    1              0.000002   endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000002   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    1              0.000002   else
    1              0.000003     let s_flags = 'nbW'
    1              0.000003     let c2 = c
    1              0.000004     let c = plist[i - 1]
    1              0.000001   endif
    1              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    1              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000002   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    1              0.000002   endif
                            
    1              0.000011   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    1              0.000001   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    1              0.000006     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    1              0.000002     try
    1              0.000207       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    1              0.000002     endtry
    1              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    1              0.000007   let stoplinebottom = line('w$')
    1              0.000006   let stoplinetop = line('w0')
    1              0.000004   if i % 2 == 0
                                let stopline = stoplinebottom
    1              0.000002   else
    1              0.000005     let stopline = stoplinetop
    1              0.000003   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000008   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    1              0.000002   else
    1              0.000008     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000002   endif
    1              0.000002   try
    1              0.000334     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    1              0.000003   endtry
                            
    1              0.000005   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    1              0.000004   endif
                            
                              " If a match is found setup match highlighting.
    1              0.000005   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    1              0.000008     if exists('*matchaddpos')
    1              0.000126       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    1              0.000003     endif
    1              0.000006     let w:paren_hl_on = 1
    1              0.000003   endif

FUNCTION  88()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim line 124
Called 392 times
Total time:   0.018956
 Self time:   0.018956

count  total (s)   self (s)
  392              0.001247     let l:result = 0
  392              0.001152     if g:NERDTreeBookmarksSort == 1
  392              0.001662         if a:firstBookmark.name <? a:secondBookmark.name
  384              0.001198             let l:result = -1
    8              0.000029         elseif a:firstBookmark.name >? a:secondBookmark.name
                                        let l:result = 1
  392              0.000697         endif
                                elseif g:NERDTreeBookmarksSort == 2
                                    if a:firstBookmark.name <# a:secondBookmark.name
                                        let l:result = -1
                                    elseif a:firstBookmark.name ># a:secondBookmark.name
                                        let l:result = 1
                                    endif
  392              0.000679     endif
  392              0.001055     return l:result

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 41
Called 396 times
Total time:   0.012398
 Self time:   0.009253

count  total (s)   self (s)
  396   0.006853   0.003708   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
   94              0.000228     return ''
  302              0.000745   endif
  302              0.001127   return a:text

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/debug.vim line 80
Called 15 times
Total time:   0.001560
 Self time:   0.001560

count  total (s)   self (s)
   15              0.000057   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   15              0.000032   endif

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.vim/bundle/vim-misc/autoload/xolox/misc/cursorhold.vim line 48
Called 11 times
Total time:   0.013554
 Self time:   0.005627

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
   33              0.000311   for handler in g:xolox#misc#cursorhold#handlers
   22              0.000491     let function = handler['function']
   22              0.000179     let last_run = get(handler, 'last_run', 0)
   22              0.000124     let interval = get(handler, 'interval', 4)
   22   0.001688   0.000845     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
   22              0.000246     let time_until_next_run = (last_run + interval) - localtime()
   22              0.000079     if time_until_next_run > 0
    5   0.000304   0.000116       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
   17              0.000041     else
   17   0.000930   0.000342       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
   17   0.007299   0.000991       call call(function, get(handler, 'arguments', []))
   17              0.000254       let handler['last_run'] = localtime()
   22              0.000048     endif
   33              0.000099   endfor

FUNCTION  airline#util#strchars()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 107
Called 144 times
Total time:   0.002326
 Self time:   0.002326

count  total (s)   self (s)
  144              0.000735   if s:has_strchars
  144              0.000857     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  188()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/creator.vim line 35
Called 6 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    6              0.000029     return 'NERD_tree_'

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 70
Called 92 times
Total time:   0.001019
 Self time:   0.001019

count  total (s)   self (s)
   92              0.000745     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 229
Called 4 times
Total time:   0.003231
 Self time:   0.000475

count  total (s)   self (s)
    4              0.000037   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000010   else
    4              0.000160     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4              0.000011   endif
                            
    4              0.000048   if !empty(colors)
    4   0.002866   0.000110     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    4              0.000009   endif

FUNCTION  <SNR>163_ws_refresh()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/whitespace.vim line 178
Called 11 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   11              0.000116   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   11              0.000030     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>174_add_section()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim line 47
Called 50 times
Total time:   0.010633
 Self time:   0.004186

count  total (s)   self (s)
   50              0.000458     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   50   0.001436   0.000605     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    4              0.000012       return
   46              0.000105     endif
   46              0.000121     if condition
                                  call a:builder.add_raw('%(')
   46              0.000095     endif
   46   0.006917   0.001301     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   46              0.000151     if condition
                                  call a:builder.add_raw('%)')
   46              0.000099     endif

FUNCTION  113()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim line 88
Called 688 times
Total time:   0.054194
 Self time:   0.014756

count  total (s)   self (s)
  688   0.052463   0.013025     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  ObsessionStatus()
    Defined: ~/.vim/bundle/vim-obsession/plugin/obsession.vim line 100
Called 66 times
Total time:   0.006602
 Self time:   0.006602

count  total (s)   self (s)
   66              0.000567   let args = copy(a:000)
   66              0.000751   let numeric = !empty(v:this_session) + exists('g:this_obsession')
   66              0.000497   if type(get(args, 0, '')) == type(0)
                                if !remove(args, 0)
                                  return ''
                                endif
   66              0.000128   endif
   66              0.000255   if empty(args)
                                let args = ['[$]', '[S]']
   66              0.000139   endif
   66              0.000381   if len(args) == 1 && numeric == 1
                                let fmt = args[0]
   66              0.000140   else
   66              0.000417     let fmt = get(args, 2-numeric, '')
   66              0.000144   endif
   66              0.000943   return substitute(fmt, '%s', get(['', 'Session', 'Obsession'], numeric), 'g')

FUNCTION  <SNR>115_filename()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 203
Called 15 times
Total time:   0.006401
 Self time:   0.000398

count  total (s)   self (s)
   15   0.006359   0.000356   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/branch.vim line 292
Called 55 times
Total time:   0.288226
 Self time:   0.005854

count  total (s)   self (s)
   55   0.277634   0.001184   let head = airline#extensions#branch#head()
   55   0.001893   0.001267   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   55              0.000487   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   55   0.006538   0.001242   let head = airline#util#shorten(head, winwidth, minwidth)
   55              0.000465   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   55              0.000694   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>111_Slash()
    Defined: ~/.vim/bundle/vim-fugitive/plugin/fugitive.vim line 262
Called 94 times
Total time:   0.002125
 Self time:   0.002125

count  total (s)   self (s)
   94              0.000548   if exists('+shellslash')
                                return tr(a:path, '\', '/')
   94              0.000204   else
   94              0.000330     return a:path
                              endif

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim line 209
Called 85170 times
Total time:   1.257894
 Self time:   1.257894

count  total (s)   self (s)
85170              1.033565     return has("win16") || has("win32") || has("win64")

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 170
Called 15 times
Total time:   0.014183
 Self time:   0.001236

count  total (s)   self (s)
   15   0.006939   0.000836   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
   15   0.007161   0.000317   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  gitgutter#all()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim line 3
Called 4 times
Total time:   0.222910
 Self time:   0.035573

count  total (s)   self (s)
    4              0.000023   let visible = tabpagebuflist()
                            
  156              0.000966   for bufnr in range(1, bufnr('$') + 1)
  152              0.000839     if buflisted(bufnr)
   52              0.025992       let file = expand('#'.bufnr.':p')
   52              0.000391       if !empty(file)
   48              0.000396         if index(visible, bufnr) != -1
    6   0.187653   0.000316           call gitgutter#process_buffer(bufnr, a:force)
   42              0.000151         elseif a:force
                                      call s:reset_tick(bufnr)
   48              0.000184         endif
   52              0.000242       endif
  152              0.000355     endif
  156              0.000545   endfor

FUNCTION  <SNR>178_get_separator_change_with_end()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 76
Called 132 times
Total time:   0.202998
 Self time:   0.021385

count  total (s)   self (s)
  132              0.000599   let sep_change = 0
  132              0.000701   if !empty(a:new_end_group) " Separator between title and the end
  132   0.096045   0.003314     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
  132              0.000290   endif
  132              0.000560   if !empty(a:old_group) " Separator between the title and the one adjacent
   84   0.056375   0.002374     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
   84              0.000405     if !empty(a:old_end_group) " Remove mis-predicted separator
   84   0.044338   0.009457       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
   84              0.000196     endif
  132              0.000256   endif
  132              0.000512   return sep_change

FUNCTION  FugitiveHead()
    Defined: ~/.vim/bundle/vim-fugitive/plugin/fugitive.vim line 110
Called 55 times
Total time:   0.203604
 Self time:   0.003105

count  total (s)   self (s)
   55   0.004367   0.001172   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   55              0.000251   if empty(dir)
    8              0.000021     return ''
   47              0.000101   endif
   47   0.198286   0.000982   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 243
Called 4 times
Total time:   0.921172
 Self time:   0.076441

count  total (s)   self (s)
    4              0.000037   let bufnr = a:0 ? a:1 : ''
    4              0.000031   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    4              0.000073   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    4              0.000025   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    4              0.000023   let airline_grouplist = []
    4              0.000070   let buffers_in_tabpage = sort(tabpagebuflist())
    4              0.000027   if exists("*uniq")
    4              0.000032     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    4              0.000011   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
    8              0.000039   for mode in reverse(mapped)
    4              0.000044     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4              0.000025       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  248              0.001780       for kvp in items(dict)
  244              0.001601         let mode_colors = kvp[1]
  244              0.005104         let name = kvp[0]
  244              0.001494         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
  244              0.000682         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  244              0.005033         if name =~# 'airline_c\d\+'
   92              0.001477           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   92              0.000674           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
   82              0.000243             continue
   10              0.000022           endif
  152              0.002022         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  116              0.000384           continue
   46              0.000125         endif
   46   0.003403   0.002024         if s:group_not_done(airline_grouplist, name.suffix)
   46   0.091334   0.001882           call airline#highlighter#exec(name.suffix, mode_colors)
   46              0.000118         endif
                            
  138              0.000879         for accent in keys(s:accents)
   92              0.000631           if !has_key(p.accents, accent)
                                        continue
   92              0.000232           endif
   92              0.001435           let colors = copy(mode_colors)
   92              0.000699           if p.accents[accent][0] != ''
   46              0.000298             let colors[0] = p.accents[accent][0]
   92              0.000545           endif
   92              0.001963           if p.accents[accent][2] != ''
   46              0.000294             let colors[2] = p.accents[accent][2]
   92              0.000215           endif
   92              0.000453           if len(colors) >= 5
   92              0.000871             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
   92              0.000218           endif
   92   0.007281   0.003348           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   92   0.154297   0.003330             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   92              0.000237           endif
  138              0.000396         endfor
   50              0.000120       endfor
                            
    4              0.000063       if empty(s:separators)
                                    " nothing to be done
                                    continue
    4              0.000008       endif
                                  " TODO: optimize this
  212              0.001568       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  208   0.606885   0.007885         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  212              0.000636       endfor
    4              0.000008     endif
    8              0.000030   endfor

FUNCTION  NERDTreeGitStatusRefreshListener()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 61
Called 696 times
Total time:   3.173141
 Self time:   0.049369

count  total (s)   self (s)
  696              0.004198     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
  696              0.001313     endif
  696              0.002588     let l:path = a:event.subject
  696   3.124409   0.013900     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
  696   0.024150   0.011333     call l:path.flagSet.clearFlags('git')
  696              0.002270     if l:flag !=# ''
    8   0.000518   0.000072         call l:path.flagSet.addFlag('git', l:flag)
  696              0.001337     endif

FUNCTION  <SNR>156_get_syn()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 37
Called 3552 times
Total time:   0.555058
 Self time:   0.555058

count  total (s)   self (s)
 3552              0.028285   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
 3552              0.010931   endif
 3552              0.013699   let color = ''
 3552              0.121524   if hlexists(a:group)
 3352              0.125799     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 3552              0.010930   endif
 3552              0.020776   if empty(color) || color == -1
                                " should always exists
  200              0.008408     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  200              0.001387     if empty(color) || color == -1
                                  let color = 'NONE'
  200              0.000549     endif
 3552              0.008632   endif
 3552              0.033448   return color

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 108
Called 19 times
Total time:   0.002185
 Self time:   0.002185

count  total (s)   self (s)
   19              0.000348   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   19              0.000268   let bomb     = &l:bomb ? '[BOM]' : ''
   19              0.000849   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   19              0.000183   if expected is# &fenc.bomb.ff
                                return ''
   19              0.000043   else
   19              0.000150     return &fenc.bomb.ff
                              endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 79
Called 45 times
Total time:   0.002878
 Self time:   0.002648

count  total (s)   self (s)
   45              0.001844   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   35              0.000135     return a:arg
   10   0.000405   0.000175   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   10              0.000030   else
   10              0.000093     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 124
Called 107 times
Total time:   0.009827
 Self time:   0.009827

count  total (s)   self (s)
  107              0.001863   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  107              0.006866   return match(a:name, pat) > -1

FUNCTION  <SNR>156_group_not_done()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/highlighter.vim line 25
Called 138 times
Total time:   0.005312
 Self time:   0.005312

count  total (s)   self (s)
  138              0.001514   if index(a:list, a:name) == -1
  138              0.001047     call add(a:list, a:name)
  138              0.001765     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  <SNR>123_persist()
    Defined: ~/.vim/bundle/vim-obsession/plugin/obsession.vim line 69
Called 4 times
Total time:   0.000677
 Self time:   0.000677

count  total (s)   self (s)
    4              0.000026   if exists('g:SessionLoad')
                                return ''
    4              0.000008   endif
    4              0.000024   let sessionoptions = &sessionoptions
    4              0.000024   if exists('g:this_obsession')
                                try
                                  set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
                                  execute 'mksession! '.fnameescape(g:this_obsession)
                                  let body = readfile(g:this_obsession)
                                  call insert(body, 'let g:this_session = v:this_session', -3)
                                  call insert(body, 'let g:this_obsession = v:this_session', -3)
                                  if type(get(g:, 'obsession_append')) == type([])
                                    for line in g:obsession_append
                                      call insert(body, line, -3)
                                    endfor
                                  endif
                                  call writefile(body, g:this_obsession)
                                  let g:this_session = g:this_obsession
                                  exe s:doautocmd_user('Obsession')
                                catch
                                  unlet g:this_obsession
                                  let &l:readonly = &l:readonly
                                  return 'echoerr '.string(v:exception)
                                finally
                                  let &sessionoptions = sessionoptions
                                endtry
    4              0.000011   endif
    4              0.000013   return ''

FUNCTION  <SNR>135_dopopd()
    Defined: ~/.fzf/plugin/fzf.vim line 483
Called 4 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    4              0.000025   if !exists('w:fzf_pushd')
    4              0.000013     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet w:fzf_pushd

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline.vim line 273
Called 41 times
Total time:   0.000787
 Self time:   0.000787

count  total (s)   self (s)
   41              0.000319   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   41              0.000088   endif

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim line 226
Called 9 times
Total time:   0.000393
 Self time:   0.000393

count  total (s)   self (s)
    9              0.000048     let l:min = 0
    9              0.000070     let l:max = len(a:loclist) - 1
                            
    9              0.000035     while 1
    9              0.000055         if l:max < l:min
    9              0.000029             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/bundle/vim-fugitive/autoload/fugitive.vim line 283
Called 94 times
Total time:   0.006915
 Self time:   0.006915

count  total (s)   self (s)
   94              0.000432   if empty(a:dir)
                                return ''
   94              0.000198   endif
   94              0.000628   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
   94              0.000207   endif
   94              0.000514   return s:commondirs[a:dir]

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 89
Called 67 times
Total time:   0.007443
 Self time:   0.004061

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   67   0.005406   0.002024   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
   12              0.000034     return ''
   55              0.000128   endif
   55              0.000278   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   55              0.000117   else
   55              0.000251     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/bundle/vim-fugitive/autoload/fugitive.vim line 492
Called 47 times
Total time:   0.197304
 Self time:   0.104806

count  total (s)   self (s)
   47              0.000311   let dir = a:0 > 1 ? a:2 : s:Dir()
   47   0.102051   0.056037   if empty(dir) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                return ''
   47              0.000141   endif
   47   0.091612   0.045128   let head = readfile(fugitive#Find('.git/HEAD', dir))[0]
   47              0.001052   if head =~# '^ref: '
   47              0.001142     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim line 177
Called 33985 times
Total time:   0.301307
 Self time:   0.301307

count  total (s)   self (s)
33985              0.205098     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  34()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/path.vim line 607
Called 34489 times
Total time:   1.824626
 Self time:   1.308098

count  total (s)   self (s)
                            
34489   1.002205   0.485677     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
34489              0.065956     endif
                            
34489              0.081184     return '/'

FUNCTION  NERDTreeGitStatusRefresh()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 75
Called 7 times
Total time:   2.529110
 Self time:   0.075348

count  total (s)   self (s)
    7              0.000086     let b:NERDTreeCachedGitFileStatus = {}
    7              0.000031     let b:NERDTreeCachedGitDirtyDir   = {}
    7              0.000026     let b:NOT_A_GIT_REPOSITORY        = 1
                            
    7   0.002583   0.000578     let l:root = fnamemodify(b:NERDTree.root.path.str(), ':p:gs?\\?/?:S')
    7              0.000049     let l:gitcmd = 'git -c color.status=false -C ' . l:root . ' status -s'
    7              0.000022     if g:NERDTreeShowIgnoredStatus
                                    let l:gitcmd = l:gitcmd . ' --ignored'
    7              0.000015     endif
    7              0.000042     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
    7              0.000013     endif
    7   2.514986   0.065444     let l:statusesStr = system(l:gitcmd)
    7              0.000903     let l:statusesSplit = split(l:statusesStr, '\n')
    7              0.000252     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
    7              0.000027     endif
    7              0.000062     let b:NOT_A_GIT_REPOSITORY = 0
                            
   28              0.000157     for l:statusLine in l:statusesSplit
                                    " cache git status of files
   21              0.000590         let l:pathStr = substitute(l:statusLine, '...', '', '')
   21              0.000294         let l:pathSplit = split(l:pathStr, ' -> ')
   21              0.000113         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
   21              0.000048         else
   21              0.002031             let l:pathStr = l:pathSplit[0]
   21              0.000051         endif
   21   0.001972   0.000903         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
   21              0.000621         if l:pathStr =~# '\.\./.*'
   14              0.000069             continue
    7              0.000014         endif
    7   0.000476   0.000346         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
    7              0.000159         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
    7              0.000028         if l:statusKey == 'Ignored'
                                        if isdirectory(l:pathStr)
                                            let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
                                        endif
    7              0.000016         else
    7   0.001397   0.000381             call s:NERDTreeCacheDirtyDir(l:pathStr)
    7              0.000015         endif
   14              0.000039     endfor

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/bundle/nerdtree/autoload/nerdtree.vim line 167
Called 8 times
Total time:   0.001367
 Self time:   0.001367

count  total (s)   self (s)
    8              0.000121     let old_ei = &ei
    8              0.000025     if a:ignoreAll
    8              0.000092         set ei=all
    8              0.000016     endif
    8              0.000868     exec a:cmd
    8              0.000089     let &ei = old_ei

FUNCTION  airline#extensions#obsession#get_status()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/obsession.vim line 20
Called 66 times
Total time:   0.008691
 Self time:   0.002089

count  total (s)   self (s)
   66   0.008415   0.001813   return ObsessionStatus((g:airline#extensions#obsession#indicator_text . s:spc), '')

FUNCTION  indent_guides#init_matches()
    Defined: ~/.vim/bundle/vim-indent-guides/autoload/indent_guides.vim line 176
Called 8 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
    8              0.000264   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 118
Called 15 times
Total time:   0.001108
 Self time:   0.000548

count  total (s)   self (s)
   15   0.000951   0.000391   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   15              0.000091   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 220
Called 15 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
   15              0.000273   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim line 18
Called 47 times
Total time:   0.004421
 Self time:   0.002073

count  total (s)   self (s)
   47   0.004288   0.001940   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim line 5
Called 9 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    9              0.000077     return call('mode', a:000)

FUNCTION  209()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim line 7
Called 8 times
Total time:   0.000446
 Self time:   0.000282

count  total (s)   self (s)
    8   0.000269   0.000105     let flags = self._flagsForScope(a:scope)
    8              0.000071     if index(flags, a:flag) == -1
    8              0.000040         call add(flags, a:flag)
    8              0.000017     end

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim line 284
Called 9 times
Total time:   0.000490
 Self time:   0.000395

count  total (s)   self (s)
    9              0.000028     try
    9   0.000263   0.000168         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
    9              0.000030     endtry
                            
    9              0.000024     return 0

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/parts.vim line 59
Called 55 times
Total time:   0.000975
 Self time:   0.000975

count  total (s)   self (s)
   55              0.000684   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  210()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim line 15
Called 696 times
Total time:   0.012817
 Self time:   0.012817

count  total (s)   self (s)
  696              0.010767     let self._flags[a:scope] = []

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 35
Called 192 times
Total time:   0.010393
 Self time:   0.010393

count  total (s)   self (s)
  192              0.002271   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
  192              0.002535   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
  192              0.001701   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
  192              0.000425   endif
  192              0.000608   return _

FUNCTION  214()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim line 45
Called 688 times
Total time:   0.027726
 Self time:   0.027726

count  total (s)   self (s)
  688              0.002135     let flagstring = ""
 1376              0.005664     for i in values(self._flags)
  688              0.002969         let flagstring .= join(i)
 1376              0.003060     endfor
                            
  688              0.002347     if len(flagstring) == 0
  680              0.001526         return ""
    8              0.000013     endif
                            
    8              0.000027     return '[' . flagstring . ']'

FUNCTION  <SNR>79_NERDTreeTrimDoubleQuotes()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 139
Called 28 times
Total time:   0.001411
 Self time:   0.001411

count  total (s)   self (s)
   28              0.000654     let l:toReturn = substitute(a:pathStr, '^"', '', '')
   28              0.000427     let l:toReturn = substitute(l:toReturn, '"$', '', '')
   28              0.000110     return l:toReturn

FUNCTION  <SNR>161_ModifierFlags()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/fugitiveline.vim line 10
Called 57 times
Total time:   0.000806
 Self time:   0.000806

count  total (s)   self (s)
   57              0.000607   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>115_exists_file()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 207
Called 15 times
Total time:   0.018042
 Self time:   0.011584

count  total (s)   self (s)
   15   0.017921   0.011463   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  220()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim line 99
Called 8 times
Total time:   0.004516
 Self time:   0.000370

count  total (s)   self (s)
    8   0.001442   0.000090     call g:NERDTree.MustBeOpen()
    8   0.003045   0.000251     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w", 1)

FUNCTION  226()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim line 146
Called 211 times
Total time:   0.030004
 Self time:   0.029953

count  total (s)   self (s)
  211              0.001209     if exists("t:NERDTreeBufName")
  208              0.027094         return bufwinnr(t:NERDTreeBufName)
    3              0.000008     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
    9              0.000066     for w in range(1,winnr('$'))
    6   0.000251   0.000200         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
    6              0.000016         endif
    9              0.000023     endfor
                            
    3              0.000008     return -1

FUNCTION  227()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim line 162
Called 19 times
Total time:   0.003086
 Self time:   0.000327

count  total (s)   self (s)
   19   0.003038   0.000279     return s:NERDTree.GetWinNum() != -1

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/bundle/vim-gitgutter/plugin/gitgutter.vim line 180
Called 47 times
Total time:   0.005363
 Self time:   0.000942

count  total (s)   self (s)
   47   0.005245   0.000824   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/quickfix.vim line 14
Called 4 times
Total time:   0.000690
 Self time:   0.000690

count  total (s)   self (s)
    4              0.000021   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    4              0.000013   endif

FUNCTION  <SNR>79_CursorHoldUpdate()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 263
Called 11 times
Total time:  13.802069
 Self time:   0.002624

count  total (s)   self (s)
   11              0.000055     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
   11              0.000023     endif
                            
   11   0.002185   0.000250     if !g:NERDTree.IsOpen()
    3              0.000011         return
    8              0.000017     endif
                            
                                " Do not update when a special buffer is selected
    8              0.000046     if !empty(&l:buftype)
                                    return
    8              0.000014     endif
                            
    8              0.000041     let l:winnr = winnr()
    8              0.000040     let l:altwinnr = winnr('#')
                            
    8   0.004703   0.000187     call g:NERDTree.CursorToTreeWin()
    8  12.933545   0.000442     call b:NERDTree.root.refreshFlags()
    8   0.860053   0.000162     call NERDTreeRender()
                            
    8              0.000083     exec l:altwinnr . 'wincmd w'
    8              0.000859     exec l:winnr . 'wincmd w'

FUNCTION  230()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim line 177
Called 8 times
Total time:   0.001352
 Self time:   0.000201

count  total (s)   self (s)
    8   0.001277   0.000126     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
    8              0.000017     endif

FUNCTION  232()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim line 193
Called 1376 times
Total time:   0.024097
 Self time:   0.024097

count  total (s)   self (s)
 1376              0.006889     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
 1376              0.002681     endif
 1376              0.003977     return s:NERDTree._PathFilters

FUNCTION  235()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim line 211
Called 8 times
Total time:   0.859593
 Self time:   0.000163

count  total (s)   self (s)
    8   0.859571   0.000141     call self.ui.render()

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim line 14
Called 15 times
Total time:   0.412551
 Self time:   0.410672

count  total (s)   self (s)
   15   0.002033   0.000473   call gitgutter#debug#log('[async] '.a:cmd)
                            
   15              0.000158   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   15   0.000678   0.000359   let command = s:build_command(a:cmd)
                            
   15              0.000130   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
   15              0.000035   else
   15              0.408297     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
   15              0.000137   endif

FUNCTION  <SNR>174_get_section()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/default.vim line 20
Called 68 times
Total time:   0.008655
 Self time:   0.006841

count  total (s)   self (s)
   68              0.000533   if has_key(s:section_truncate_width, a:key)
   42   0.002104   0.000854     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   14              0.000042       return ''
   28              0.000059     endif
   54              0.000106   endif
   54              0.000235   let spc = g:airline_symbols.space
   54              0.000438   if !exists('g:airline_section_{a:key}')
                                return ''
   54              0.000105   endif
   54   0.001968   0.001404   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   54              0.001485   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   54              0.000357   return empty(text) ? '' : prefix.text.suffix

FUNCTION  242()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 264
Called 8 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    8              0.000030     return self._showBookmarks

FUNCTION  243()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 269
Called 1376 times
Total time:   0.007187
 Self time:   0.007187

count  total (s)   self (s)
 1376              0.003972     return self._showFiles

FUNCTION  245()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 279
Called 1376 times
Total time:   0.007159
 Self time:   0.007159

count  total (s)   self (s)
 1376              0.003932     return self._showHidden

FUNCTION  248()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 298
Called 1376 times
Total time:   0.007964
 Self time:   0.007964

count  total (s)   self (s)
 1376              0.004650     return self._ignoreEnabled == 1

FUNCTION  249()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 303
Called 32 times
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
   32              0.000159     return g:NERDTreeMinimalUI

FUNCTION  133()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim line 319
Called 696 times
Total time:   0.799725
 Self time:   0.743740

count  total (s)   self (s)
  696              0.001977     let output = ""
  696              0.001812     if a:drawText ==# 1
                            
  688              0.003396         let treeParts = repeat('  ', a:depth - 1)
                            
  688              0.002150         if !self.path.isDirectory
  688              0.002197             let treeParts = treeParts . '  '
  688              0.001270         endif
                            
  688   0.061013   0.006819         let line = treeParts . self.displayString()
                            
  688              0.002556         let output = output . line . "\n"
  696              0.001265     endif
                            
                                " if the node is an open dir, draw its children
  696              0.002295     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    8   0.219250   0.000132         let childNodesToDraw = self.getVisibleChildren()
                            
    8   0.324487   0.000258         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
    8              0.000025         elseif len(childNodesToDraw) > 0
  696              0.001721             for i in childNodesToDraw
  688              0.007020                 let output = output . i._renderToString(a:depth + 1, 1)
  696              0.001523             endfor
    8              0.000013         endif
  696              0.001231     endif
                            
  696              0.001776     return output

FUNCTION  <SNR>182_CreateCountDict()
    Defined: ~/.vim/bundle/ale/autoload/ale/statusline.vim line 5
Called 16 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   16              0.000204     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim line 62
Called 9 times
Total time:   0.016087
 Self time:   0.006782

count  total (s)   self (s)
    9              0.000087     let l:buffer = bufnr('')
                            
    9              0.000041     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    9              0.000019     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    9              0.000049     if mode(1) isnot# 'n'
                                    return
    9              0.000020     endif
                            
    9   0.008805   0.001019     if ale#ShouldDoNothing(l:buffer)
                                    return
    9              0.000682     endif
                            
    9   0.003705   0.002186     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    9              0.000030     if g:ale_echo_cursor
    9              0.000041         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
    9              0.000046         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
    9              0.000019         endif
    9              0.000021     endif
                            
    9              0.000030     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    9              0.000019     endif

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 227
Called 12 times
Total time:   0.002174
 Self time:   0.001072

count  total (s)   self (s)
   12   0.001642   0.000540   let builder = airline#builder#new(a:context)
   12              0.000057   let builder._build = builder.build
   12              0.000190   call extend(builder, s:prototype, 'force')
   12              0.000058   return builder

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim line 194
Called 192 times
Total time:   0.060276
 Self time:   0.013706

count  total (s)   self (s)
  192              0.001571   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
  192              0.001669   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
  192   0.055910   0.009340   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>178_evaluate_tabline()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/builder.vim line 209
Called 144 times
Total time:   0.115239
 Self time:   0.031582

count  total (s)   self (s)
  144              0.000825   let tabline = a:tabline
  144   0.091560   0.007903   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
  144              0.009023   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
  144              0.004351   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
  144              0.001899   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
  144              0.001117   let tabline = substitute(tabline, '%=', '', 'g')
  144              0.001209   let tabline = substitute(tabline, '%\d*\*', '', 'g')
  144              0.001687   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
  144              0.000398   endif
  144              0.000462   return tabline

FUNCTION  251()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 313
Called 8 times
Total time:   0.163028
 Self time:   0.007923

count  total (s)   self (s)
                            
    8   0.000098   0.000055     if !self.isMinimal()
    8              0.000071         call setline(line(".")+1, ">----------Bookmarks----------")
    8              0.000051         call cursor(line(".")+1, col("."))
    8              0.000017     endif
                            
    8              0.000037     if g:NERDTreeBookmarksSort == 1 || g:NERDTreeBookmarksSort == 2
    8   0.021813   0.000166         call g:NERDTreeBookmark.SortBookmarksList()
    8              0.000018     endif
                            
  192   0.000748   0.000607     for i in g:NERDTreeBookmark.Bookmarks()
  184   0.136807   0.003533         call setline(line(".")+1, i.str())
  184              0.001798         call cursor(line(".")+1, col("."))
  192              0.000417     endfor
                            
    8              0.000061     call setline(line(".")+1, '')
    8              0.000064     call cursor(line(".")+1, col("."))

FUNCTION  256()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 385
Called 8 times
Total time:   0.859430
 Self time:   0.004776

count  total (s)   self (s)
    8              0.000339     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    8              0.000051     let curLine = line(".")
    8              0.000046     let curCol = col(".")
    8              0.000044     let topLine = line("w0")
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    8              0.000940     silent 1,$delete _
                            
    8   0.003072   0.000090     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    8   0.000115   0.000069     if !self.isMinimal()
    8              0.000097         call setline(line(".")+1, "")
    8              0.000062         call cursor(line(".")+1, col("."))
    8              0.000015     endif
                            
    8   0.000200   0.000065     if self.getShowBookmarks()
    8   0.163143   0.000115         call self._renderBookmarks()
    8              0.000016     endif
                            
                                " add the 'up a dir' line
    8   0.000159   0.000095     if !self.isMinimal()
    8   0.000436   0.000344         call setline(line(".")+1, s:UI.UpDirLine())
    8              0.000052         call cursor(line(".")+1, col("."))
    8              0.000016     endif
                            
                                " draw the header line
    8   0.008659   0.000131     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    8              0.000070     call setline(line(".")+1, header)
    8              0.000044     call cursor(line(".")+1, col("."))
                            
                                " draw the tree
    8   0.680527   0.000748     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    8              0.000150     silent 1,1delete _
                            
                                " restore the view
    8              0.000051     let old_scrolloff=&scrolloff
    8              0.000125     let &scrolloff=0
    8              0.000051     call cursor(topLine, 1)
    8              0.000182     normal! zt
    8              0.000037     call cursor(curLine, curCol)
    8              0.000051     let &scrolloff = old_scrolloff
                            
    8              0.000075     setlocal readonly nomodifiable

FUNCTION  <SNR>79_NERDTreeGetFileGitStatusKey()
    Defined: ~/.vim/bundle/nerdtree-git-plugin/nerdtree_plugin/git_status.vim line 197
Called 7 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    7              0.000057     if a:us ==# '?' && a:them ==# '?'
    7              0.000023         return 'Untracked'
                                elseif a:us ==# ' ' && a:them ==# 'M'
                                    return 'Modified'
                                elseif a:us =~# '[MAC]'
                                    return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
                                    return 'Deleted'
                                elseif a:us ==# '!'
                                    return 'Ignored'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  <SNR>187_discover_supported_filetypes()
    Defined: ~/.vim/bundle/vim-easytags/autoload/xolox/easytags/filetypes.vim line 86
Called 7 times
Total time:   0.000876
 Self time:   0.000876

count  total (s)   self (s)
                              " Initialize predefined groups & mappings and discover supported file types.
    7              0.000052   if !s:discovered_filetypes
                                " Discover the file types supported by Exuberant Ctags?
                                let command_line = xolox#easytags#ctags_command()
                                if !empty(command_line)
                                  let starttime = xolox#misc#timer#start()
                                  let command_line .= ' --list-languages'
                                  for line in xolox#misc#os#exec({'command': command_line})['stdout']
                                    if line =~ '\[disabled\]$'
                                      " Ignore languages that have been explicitly disabled using `--languages=-Vim'.
                                      continue
                                    elseif line =~ '^\w\S*$'
                                      call add(s:supported_filetypes, xolox#easytags#filetypes#to_vim(xolox#misc#str#trim(line)))
                                    elseif line =~ '\S'
                                      call xolox#misc#msg#warn("easytags.vim %s: Failed to parse line of output from ctags --list-languages: %s", g:xolox#easytags#version, string(line))
                                    endif
                                  endfor
                                  let msg = "easytags.vim %s: Retrieved %i supported languages in %s."
                                  call xolox#misc#timer#stop(msg, g:xolox#easytags#version, len(s:supported_filetypes), starttime)
                                endif
                                " Add file types supported by language specific programs.
                                call extend(s:supported_filetypes, keys(xolox#misc#option#get('easytags_languages', {})))
                                " Don't run s:discover_supported_filetypes() more than once.
                                let s:discovered_filetypes = 1
    7              0.000016   endif

FUNCTION  <SNR>115_is_file_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 69
Called 17 times
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
   17              0.000224   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  264()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/ui.vim line 521
Called 8 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    8              0.000044     return '.. (up a dir)'

FUNCTION  265()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/event.vim line 6
Called 696 times
Total time:   0.022718
 Self time:   0.022718

count  total (s)   self (s)
  696              0.004259     let newObj = copy(self)
  696              0.003061     let newObj.nerdtree = a:nerdtree
  696              0.002433     let newObj.subject = a:subject
  696              0.002688     let newObj.action = a:action
  696              0.002622     let newObj.params = a:params
  696              0.001891     return newObj

FUNCTION  267()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim line 14
Called 696 times
Total time:   3.273367
 Self time:   0.049421

count  total (s)   self (s)
  696   0.032075   0.009357     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
 1392   0.038543   0.010456     for listener in s:Notifier.GetListenersForEvent(a:event)
  696   3.188881   0.015740         call {listener}(event)
 1392              0.003188     endfor

FUNCTION  268()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim line 22
Called 696 times
Total time:   0.014198
 Self time:   0.014198

count  total (s)   self (s)
  696              0.004591     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
  696              0.001702     endif
  696              0.002477     return s:refreshListenersMap

FUNCTION  269()
    Defined: ~/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim line 29
Called 696 times
Total time:   0.028087
 Self time:   0.013889

count  total (s)   self (s)
  696   0.021136   0.006938     let listenersMap = s:Notifier.GetListenersMap()
  696              0.004353     return get(listenersMap, a:name, [])

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/util.vim line 138
Called 55 times
Total time:   0.001577
 Self time:   0.001577

count  total (s)   self (s)
   55              0.000597   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
   55              0.000124   endif
   55              0.000224   return s:has_lawrencium

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim line 470
Called 9 times
Total time:   0.001519
 Self time:   0.001126

count  total (s)   self (s)
    9              0.000174     let l:info = get(g:ale_buffer_info, a:buffer, {})
    9              0.000172     let l:loclist = get(l:info, 'loclist', [])
    9              0.000062     let l:pos = getpos('.')
    9   0.000657   0.000264     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    9              0.000078     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    9              0.000041     return [l:info, l:loc]

FUNCTION  <SNR>86_Tlist_Refresh()
    Defined: ~/.vim/bundle/taglist.vim/plugin/taglist.vim line 2793
Called 4 times
Total time:   0.012863
 Self time:   0.003779

count  total (s)   self (s)
    4   0.000523   0.000206     call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' . s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
                                " If we are entering the buffer from one of the taglist functions, then
                                " no need to refresh the taglist window again.
    4              0.000015     if s:Tlist_Skip_Refresh
                                    " We still need to update the taglist menu
                                    if g:Tlist_Show_Menu
                                        call s:Tlist_Menu_Update_File(0)
                                    endif
                                    return
    4              0.000008     endif
                            
                                " If part of the winmanager plugin and not configured to process
                                " tags always and not configured to display the tags menu, then return
    4              0.000030     if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
                                    return
    4              0.000009     endif
                            
                                " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
    4              0.000021     if &buftype != ''
                                    return
    4              0.000009     endif
                            
    4              0.000628     let filename = fnamemodify(bufname('%'), ':p')
    4   0.000946   0.000262     let ftype = s:Tlist_Get_Buffer_Filetype('%')
                            
                                " If the file doesn't support tag listing, skip it
    4   0.008180   0.000243     if s:Tlist_Skip_File(filename, ftype)
    2              0.000005         return
    2              0.000004     endif
                            
    2              0.001035     let tlist_win = bufwinnr(g:TagList_title)
                            
                                " If the taglist window is not opened and not configured to process
                                " tags always and not displaying the tags menu, then return
    2              0.000018     if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
                                    return
    2              0.000004     endif
                            
    2   0.000265   0.000119     let fidx = s:Tlist_Get_File_Index(filename)
    2              0.000009     if fidx == -1
                                    " Check whether this file is removed based on user request
                                    " If it is, then don't display the tags for this file
                                    if s:Tlist_User_Removed_File(filename)
                                        return
                                    endif
                            
                                    " If the taglist should not be auto updated, then return
                                    if !g:Tlist_Auto_Update
                                        return
                                    endif
    2              0.000005     endif
                            
    2              0.000014     let cur_lnum = line('.')
                            
    2              0.000008     if fidx == -1
                                    " Update the tags for the file
                                    let fidx = s:Tlist_Process_File(filename, ftype)
    2              0.000005     else
    2              0.000362         let mtime = getftime(filename)
    2              0.000018         if s:tlist_{fidx}_mtime != mtime
                                        " Invalidate the tags listed for this file
                                        let s:tlist_{fidx}_valid = 0
                            
                                        " Update the taglist and the window
                                        call Tlist_Update_File(filename, ftype)
                            
                                        " Store the new file modification time
                                        let s:tlist_{fidx}_mtime = mtime
    2              0.000006         endif
    2              0.000004     endif
                            
                                " Update the taglist window
    2              0.000006     if tlist_win != -1
                                    " Disable screen updates
                                    let old_lazyredraw = &lazyredraw
                                    set nolazyredraw
                            
                                    " Save the current window number
                                    let save_winnr = winnr()
                            
                                    " Goto the taglist window
                                    call s:Tlist_Window_Goto_Window()
                            
                                    if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
                                        " Save the cursor position
                                        let save_line = line('.')
                                        let save_col = col('.')
                                    endif
                            
                                    " Update the taglist window
                                    call s:Tlist_Window_Refresh_File(filename, ftype)
                            
                                    " Open the fold for the file
                                    exe "silent! " . s:tlist_{fidx}_start . "," . s:tlist_{fidx}_end . "foldopen!"
                            
                                    if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
                                        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
                                            " If displaying tags for only one file in the taglist
                                            " window and about to display the tags for a new file,
                                            " then center the current tag line for the new file
                                            let center_tag_line = 1
                                        else
                                            let center_tag_line = 0
                                        endif
                            
                                        " Highlight the current tag
                                        call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
                                    else
                                        " Restore the cursor position
                                        if v:version >= 601
                                            call cursor(save_line, save_col)
                                        else
                                            exe save_line
                                            exe 'normal! ' . save_col . '|'
                                        endif
                                    endif
                            
                                    " Jump back to the original window
                                    if save_winnr != winnr()
                                        call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
                                    endif
                            
                                    " Restore screen updates
                                    let &lazyredraw = old_lazyredraw
    2              0.000004     endif
                            
                                " Update the taglist menu
    2              0.000006     if g:Tlist_Show_Menu
                                    call s:Tlist_Menu_Update_File(0)
    2              0.000004     endif

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 55 times
Total time:   0.001787
 Self time:   0.001787

count  total (s)   self (s)
   55              0.000738   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   55              0.000720     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  289()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim line 137
Called 30 times
Total time:   0.002868
 Self time:   0.000798

count  total (s)   self (s)
   30   0.002761   0.000691   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  airline#extensions#ctrlp#apply()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ctrlp.vim line 69
Called 4 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    4              0.000068   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/hunks.vim line 62
Called 55 times
Total time:   0.048013
 Self time:   0.023370

count  total (s)   self (s)
   55              0.000436   if !get(w:, 'airline_active', 0)
                                return ''
   55              0.000150   endif
                              " Cache values, so that it isn't called too often
   55   0.004428   0.002543   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
   55              0.000121   endif
   55   0.017098   0.001261   let hunks = airline#extensions#hunks#get_raw_hunks()
   55              0.000183   let string = ''
   55   0.001863   0.000921   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   55              0.000236   if !empty(hunks)
  188              0.000681     for i in [0, 1, 2]
  141   0.008589   0.004771       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  141              0.000305       endif
  188              0.000429     endfor
   55              0.000121   endif
   55              0.000381   let b:airline_hunks = string
   55              0.000310   let b:airline_changenr = b:changedtick
   55   0.008231   0.006070   let s:airline_winwidth = airline#util#winwidth()
   55              0.000172   return string

FUNCTION  298()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 8
Called 22 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
   22              0.000217   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  299()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 12
Called 24 times
Total time:   0.004928
 Self time:   0.003402

count  total (s)   self (s)
   24              0.000324   let spc = empty(a:contents) ? '' : g:airline_symbols.space
   24   0.004486   0.002960   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  <SNR>111_Tree()
    Defined: ~/.vim/bundle/vim-fugitive/plugin/fugitive.vim line 146
Called 94 times
Total time:   0.003382
 Self time:   0.003382

count  total (s)   self (s)
   94              0.000452   let dir = a:path
   94              0.001403   if dir =~# '/\.git$'
   94              0.000908     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>185_StopCursorTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim line 55
Called 48 times
Total time:   0.002284
 Self time:   0.002284

count  total (s)   self (s)
   48              0.000324     if s:cursor_timer != -1
   29              0.000284         call timer_stop(s:cursor_timer)
   29              0.000146         let s:cursor_timer = -1
   48              0.000954     endif

FUNCTION  <SNR>162_airline_ale_get_line_number()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/ale.vim line 63
Called 16 times
Total time:   0.000916
 Self time:   0.000654

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
   16              0.000166   if exists("*ale#statusline#FirstProblem")
   16   0.000653   0.000391     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  airline#builder#new()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/builder.vim line 232
Called 24 times
Total time:   0.001833
 Self time:   0.001833

count  total (s)   self (s)
   24              0.000754   let builder = copy(s:prototype)
   24              0.000120   let builder._context = a:context
   24              0.000111   let builder._sections = []
                            
   24              0.000529   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   24              0.000090   return builder

FUNCTION  airline#extensions#tabline#add_tab_label()
    Defined: ~/.vim/bundle/vim-airline/autoload/airline/extensions/tabline.vim line 246
Called 12 times
Total time:   0.006721
 Self time:   0.002559

count  total (s)   self (s)
   12              0.000603   if get(g:, 'airline#extensions#tabline#show_tab_count', 1) && tabpagenr('$') > 1
   12   0.005922   0.001760     call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
   12              0.000027   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   11  13.802069   0.002624  <SNR>79_CursorHoldUpdate()
    8  12.933103   0.021937  164()
  696  12.888400   0.021478  38()
  688  10.578392   0.018256  130()
  696   9.593555   0.526840  3()
16192   9.090882   0.692755  32()
33985   8.575139   4.214883  40()
33793   4.053897   1.772761  45()
  696   3.273367   0.049421  267()
  696   3.173141   0.049369  NERDTreeGitStatusRefreshListener()
  696   3.110509   0.135076  NERDTreeGetGitStatusPrefix()
    7   2.529110   0.075348  NERDTreeGitStatusRefresh()
34489   1.824626   1.308098  34()
85170   1.257894             nerdtree#runningWindows()
 1776   1.195252   0.585581  airline#highlighter#get_highlight()
   12   1.030668   0.002208  airline#extensions#tabline#get()
   12   1.028460   0.009334  airline#extensions#tabline#tabs#get()
   12   1.004329   0.024627  308()
  370   0.969181   0.075633  <SNR>156_exec_separator()
   88   0.962009   0.036430  airline#check_mode()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
33985   8.575139   4.214883  40()
33793   4.053897   1.772761  45()
34489   1.824626   1.308098  34()
85170              1.257894  nerdtree#runningWindows()
  696   0.799725   0.743740  133()
16192   9.090882   0.692755  32()
 1776   1.195252   0.585581  airline#highlighter#get_highlight()
 3552              0.555058  <SNR>156_get_syn()
  696   9.593555   0.526840  3()
   15   0.412551   0.410672  gitgutter#async#execute()
33985              0.301307  nerdtree#has_opt()
 1376   0.393059   0.162705  27()
  512   0.610581   0.146476  airline#highlighter#exec()
  696   3.110509   0.135076  NERDTreeGetGitStatusPrefix()
   36   0.849131   0.129768  305()
 3448              0.107859  20()
   47   0.197304   0.104806  fugitive#Head()
 1376   0.124553   0.081915  28()
  512              0.079556  <SNR>156_CheckDefined()
  184   0.133274   0.076549  102()

